<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title>The Refactoring Tales - </title>
  <style type="text/css">code{white-space: pre;}</style>
  <!--[if lt IE 9]>
    <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
.carbon{width:350px;margin:10px auto 40px auto;font-size:14px;background:#eee}
.carbon .carbon-wrap{display:flex;border-radius:3px}.carbon .carbon-wrap .carbon-img{display:block}.carbon .carbon-wrap .carbon-text{display:block;margin-left:15px;padding-top:10px;padding-right:7px}.carbon .carbon-poweredby{text-align:right;width:100%;display:block;padding:2px 7px 7px 2px}

.
  </style>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <h1>The Refactoring Tales</h1>
  <h3>By Jack Franklin (<a href="http://twitter.com/jack_franklin">@jack_franklin</a>)</h3>
  <p><strong>This book is not being actively worked on, but is left online for posterity.</strong></p>
  <p>If you enjoy my writing, you might like to <a href="/">check out my latest blog posts</a> or <a href="/testing-react-enzyme-jest">my course on Testing React applications</a>.</p>
      <div class="carbon">
        <script
          async
          type="text/javascript"
          src="https://cdn.carbonads.com/carbon.js?serve=CKYIEK7M&placement=javascriptplaygroundcom"
          id="_carbonads_js"
        ></script>
      </div>
<nav id="TOC">
<ul>
<li><a href="#introduction">Introduction</a><ul>
<li><a href="#thanks">Thanks</a></li>
<li><a href="#changelog">Changelog</a></li>
<li><a href="#refactoring">Refactoring</a></li>
<li><a href="#tests">Tests</a></li>
</ul></li>
<li><a href="#tale-1-terrible-tabs">Tale 1: Terrible Tabs</a><ul>
<li><a href="#reuse-of-selectors">Reuse of Selectors</a></li>
<li><a href="#more-duplication">More Duplication</a></li>
<li><a href="#step-back">Step Back</a></li>
<li><a href="#higher-level-duplication">Higher level duplication</a></li>
<li><a href="#merging-the-branches">Merging the branches</a></li>
<li><a href="#one-method-to-rule-them-all">One method to rule them all</a></li>
<li><a href="#reflection">Reflection</a></li>
</ul></li>
<li><a href="#tale-2-cringey-carousels">Tale 2: Cringey Carousels</a><ul>
<li><a href="#the-carousel">The Carousel</a></li>
<li><a href="#return-false-the-anti-pattern">return false; the anti-pattern</a></li>
<li><a href="#on-and-off">on() and off()</a></li>
<li><a href="#repeated-numbers">Repeated Numbers</a></li>
<li><a href="#caching-selectors">Caching selectors</a></li>
<li><a href="#functions">functions</a></li>
<li><a href="#summary">Summary</a></li>
</ul></li>
<li><a href="#tale-3-async-abominations">Tale 3: Async Abominations</a><ul>
<li><a href="#the-code">The code</a></li>
<li><a href="#back-to-the-beginning">Back to the beginning</a></li>
<li><a href="#abstracting-functions">Abstracting functions</a></li>
</ul></li>
<li><a href="#tale-4-parsing-problems">Tale 4: Parsing Problems</a><ul>
<li><a href="#email-sending"> Email Sending</a></li>
<li><a href="#single-responsibility-principle">Single Responsibility Principle</a></li>
<li><a href="#an-improvement">An improvement</a></li>
<li><a href="#coupling">Coupling</a></li>
<li><a href="#publish-and-subscribe">Publish and Subscribe</a></li>
<li><a href="#conclusion">Conclusion</a></li>
</ul></li>
<li><a href="#tale-5-the-fat-controller">Tale 5: The Fat Controller</a></li>
<li><a href="#test-driven-development">Test Driven Development</a><ul>
<li><a href="#the-service">The Service</a></li>
<li><a href="#test-driven">Test Driven</a></li>
<li><a href="#conclusion-1">Conclusion</a></li>
</ul></li>
</ul>
</nav>
<h1 id="introduction">Introduction</h1>
<p>Welcome to The Refactoring Tales, a book that documents some of the refactorings and changes I’ve made in recent (and mostly real-life) projects. This book isn’t going to teach you about language constructs, conditionals, functions, or so on, but hopefully offer insight into how to take steps to make your code more readable and more importantly, maintainable.</p>
<p>Think of how much time you spend maintaining code, rather than being able to write code from scratch. Day to day, I’m not typically creating new projects, but I am maintaining, editing or refactoring existing projects. This book is just like that. Each chapter will start by looking at some existing code, and over the course of a few pages we will examine, dissect and then refactor the code into an improved alternative. Of course, the idea of code being “better” is largely subjective, but even if you don’t quite agree with every step I take, you should be able to see the overall benefits.</p>
<p>The GitHub repository for this book is here: <a href="https://github.com/jackfranklin/the-refactoring-tales">https://github.com/jackfranklin/the-refactoring-tales</a>, both the raw book files and the code samples are all there for you to take. If you spot any issues as you read this book, a new issue (or even better, a pull request!) is greatly appreciated.</p>
<h2 id="thanks">Thanks</h2>
<p>There are so many people who have thanked me along the way that it would be wrong to not include some form of list of names in this book. Thanks in particular go to Addy Osmani, Drew Neil, Guy Routledge, Katja Durrani, Adam Yeats, Stu Robson and Todd Motto along with many more who have shaped this book since the idea formed.</p>
<h2 id="changelog">Changelog</h2>
<p>If you’ve been reading this book since the beta, to help you know what’s changed, a list of changes and dates of update will be kept below.</p>
<h5 id="section">21/07/14</h5>
<ul>
<li>initial release</li>
</ul>
<h2 id="refactoring">Refactoring</h2>
<p>Before we continue I think it’s important to define just what exactly I mean when I say “refactoring”. Refactoring has lots of definitions, but I think my favourite and the one I stick to is that of Martin Fowler, in his <a href="http://martinfowler.com/books/refactoring.html">book on refactoring</a>:</p>
<blockquote>
<p>Refactoring is a controlled technique for improving the design of an existing code base. Its essence is applying a series of small behaviour-preserving transformations, each of which “too small to be worth doing”.</p>
</blockquote>
<p>We apply small changes to the code, and do so several times, until we’re left with a section of code whose design is greatly improved. Notice how they are <em>behaviour-preserving</em> transformations: a refactor should never change behaviour, merely improve the code. The idea of “better” code may be subjective, but to me when I think of good qualities for code to have, I think of it being:</p>
<ul>
<li>self documenting: methods and variables are well named and follow a consistent naming pattern</li>
<li>DRY: there is no duplication or knowledge sharing; every piece of information that could change is declared only once</li>
<li>clear in its intention; it should read somewhat like a story, and at a quick skim the overall function of that block of code should be apparent</li>
</ul>
<p>In his book <a href="http://www.wrox.com/WileyCDA/WroxTitle/productCd-0764579088.html">Professional JavaScript for Web Developers</a>, Nicholas Zakas has a brilliant definition of maintainability which cites the following characteristics: Understandable, intuitive, adaptable, extendable and debuggable. It’s these traits that I hope this book will help you adhere to and aim for.</p>
<h2 id="tests">Tests</h2>
<p>When refactoring, you need to have confidence in the fact that you’ve not broken anything. Similarly, if you do break something, you need to know immediately. This is where the benefit of having tests plays a key role. The ability to run a set of tests and get immediate feedback is fantastic, and that’s precisely what tests give you. It’s very easy these days to get started with tests, whether you’re writing Ruby, or JavaScript on the server with NodeJS, or in the browser, there are a myriad of tools available to you. This isn’t a book on testing, and I could write in huge depth on the subject, so for each example in this book, you should assume that I have tested it as I’ve gone (in actual fact for every example there is, I did have tests every time). If you want to refactor but don’t have tests, write tests. Do not ever attempt to refactor without writing any tests. Ever.</p>
<p>You should also make sure you can run your tests easily. I have mine hooked up through my editor, Vim, so I can hit a 3 key shortcut and have my tests run. Configure it however you want, and make sure it’s easy to do.</p>
<h1 id="tale-1-terrible-tabs">Tale 1: Terrible Tabs</h1>
<p>One of the most common things any new jQuery user will try to do is build some basic HTML tabs. It’s like the initiation into the jQuery world (not quite, that’s carousels, which are next up) and it serves as a good starting point to show you the first refactoring.</p>
<p>Here’s a JavaScript function called <code>tabularize</code> which, as you might expect, is a small function for creating a tabbed interface.</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> tabularize = <span class="kw">function</span>() {
  <span class="kw">var</span> active = <span class="ot">location</span>.<span class="fu">hash</span>;
  <span class="kw">if</span>(active) {
    <span class="fu">$</span>(<span class="st">&quot;.tabs&quot;</span>).<span class="fu">children</span>(<span class="st">&quot;div&quot;</span>).<span class="fu">hide</span>();
    <span class="fu">$</span>(active).<span class="fu">show</span>();
    <span class="fu">$</span>(<span class="st">&quot;.active&quot;</span>).<span class="fu">removeClass</span>(<span class="st">&quot;active&quot;</span>);
    <span class="fu">$</span>(<span class="st">&quot;.tab-link&quot;</span>).<span class="fu">each</span>(<span class="kw">function</span>() {
      <span class="kw">if</span>(<span class="fu">$</span>(<span class="kw">this</span>).<span class="fu">attr</span>(<span class="st">&quot;href&quot;</span>) === active) {
        <span class="fu">$</span>(<span class="kw">this</span>).<span class="fu">parent</span>().<span class="fu">addClass</span>(<span class="st">&quot;active&quot;</span>);
      }
    });
  }
  <span class="fu">$</span>(<span class="st">&quot;.tabs&quot;</span>).<span class="fu">find</span>(<span class="st">&quot;.tab-link&quot;</span>).<span class="fu">click</span>(<span class="kw">function</span>() {
    <span class="fu">$</span>(<span class="st">&quot;.tabs&quot;</span>).<span class="fu">children</span>(<span class="st">&quot;div&quot;</span>).<span class="fu">hide</span>();
    <span class="fu">$</span>(<span class="fu">$</span>(<span class="kw">this</span>).<span class="fu">attr</span>(<span class="st">&quot;href&quot;</span>)).<span class="fu">show</span>();
    <span class="fu">$</span>(<span class="st">&quot;.active&quot;</span>).<span class="fu">removeClass</span>(<span class="st">&quot;active&quot;</span>);
    <span class="fu">$</span>(<span class="kw">this</span>).<span class="fu">parent</span>().<span class="fu">addClass</span>(<span class="st">&quot;active&quot;</span>);
    <span class="kw">return</span> <span class="kw">false</span>;
  });
};</code></pre>
<p>The first part of the function deals with the case where there is a fragment identifier in the URL. For example, if someone visits <code>mysite.com/#tab2</code>, they should have tab 2 active when they load the page. The second part deals with a user clicking on a tab, and updating the content accordingly.</p>
<p>To help you put this together, here is the HTML that the code is applied to.</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript">&lt;div <span class="kw">class</span>=<span class="st">&quot;tabs&quot;</span>&gt;
  &lt;ul&gt;
    &lt;li <span class="kw">class</span>=<span class="st">&quot;active&quot;</span>&gt;&lt;a href=<span class="st">&quot;#tab1&quot;</span> <span class="kw">class</span>=<span class="st">&quot;tab-link&quot;</span>&gt;Tab <span class="dv">1</span>&lt;<span class="ot">/a&gt;&lt;/li</span>&gt;
    &lt;li&gt;&lt;a href=<span class="st">&quot;#tab2&quot;</span> <span class="kw">class</span>=<span class="st">&quot;tab-link&quot;</span>&gt;Tab <span class="dv">2</span>&lt;<span class="ot">/a&gt;&lt;/li</span>&gt;
    &lt;li&gt;&lt;a href=<span class="st">&quot;#tab3&quot;</span> <span class="kw">class</span>=<span class="st">&quot;tab-link&quot;</span>&gt;Tab <span class="dv">3</span>&lt;<span class="ot">/a&gt;&lt;/li</span>&gt;
  &lt;<span class="ot">/ul&gt;</span>
<span class="ot">  &lt;div id=&quot;tab1&quot;&gt;</span>
<span class="ot">    &lt;h3&gt;Tab 1&lt;/h3</span>&gt;
    &lt;p&gt;Lorem ipsum dolor sit amet&lt;<span class="ot">/p&gt;</span>
<span class="ot">  &lt;/div</span>&gt;
  &lt;div id=<span class="st">&quot;tab2&quot;</span>&gt;
    &lt;h3&gt;Tab <span class="dv">2</span>&lt;<span class="ot">/h3&gt;</span>
<span class="ot">    &lt;p&gt;Lorem ipsum dolor sit amet&lt;/p</span>&gt;
  &lt;<span class="ot">/div&gt;</span>
<span class="ot">  &lt;div id=&quot;tab3&quot;&gt;</span>
<span class="ot">    &lt;h3&gt;Tab 3&lt;/h3</span>&gt;
    &lt;p&gt;Lorem ipsum dolor sit amet&lt;<span class="ot">/p&gt;</span>
<span class="ot">  &lt;/div</span>&gt;
&lt;<span class="ot">/div&gt;</span>
<span class="ot">&lt;script&gt;</span>
<span class="ot">  $</span><span class="fl">(</span><span class="ot">tabularize</span><span class="fl">)</span><span class="ot">;</span>
<span class="ot">&lt;/script</span>&gt;</code></pre>
<p>There’s a fair bit wrong with the JavaScript above, but it’s not necessarily bad code. It performs the tasks that are required of it. There are a couple of bugs, but as refactorers, we are not here to change the behaviour of the code. It passes the tests (in the introduction we discussed how every refactoring must be backed by tests) and our aim is to change the design, not the behaviour, and pass all the tests. I won’t show the tests, as they distract from the main purpose, but rest assured I did have them when making the changes I’m about to talk through and I was careful to keep them passing.</p>
<h2 id="reuse-of-selectors">Reuse of Selectors</h2>
<p>The key to refactoring is to make the smallest steps you possibly can. The first problem I’d like to tackle is the reuse of selectors. Let’s take a look once more at that JavaScript:</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> active = <span class="ot">location</span>.<span class="fu">hash</span>;
<span class="kw">if</span>(active) {
  <span class="fu">$</span>(<span class="st">&quot;.tabs&quot;</span>).<span class="fu">children</span>(<span class="st">&quot;div&quot;</span>).<span class="fu">hide</span>();
  <span class="fu">$</span>(active).<span class="fu">show</span>();
  <span class="fu">$</span>(<span class="st">&quot;.active&quot;</span>).<span class="fu">removeClass</span>(<span class="st">&quot;active&quot;</span>);
  <span class="fu">$</span>(<span class="st">&quot;.tab-link&quot;</span>).<span class="fu">each</span>(<span class="kw">function</span>() {
    <span class="kw">if</span>(<span class="fu">$</span>(<span class="kw">this</span>).<span class="fu">attr</span>(<span class="st">&quot;href&quot;</span>) === active) {
      <span class="fu">$</span>(<span class="kw">this</span>).<span class="fu">parent</span>().<span class="fu">addClass</span>(<span class="st">&quot;active&quot;</span>);
    }
  });
}
<span class="fu">$</span>(<span class="st">&quot;.tabs&quot;</span>).<span class="fu">find</span>(<span class="st">&quot;.tab-link&quot;</span>).<span class="fu">click</span>(<span class="kw">function</span>() {
  <span class="fu">$</span>(<span class="st">&quot;.tabs&quot;</span>).<span class="fu">children</span>(<span class="st">&quot;div&quot;</span>).<span class="fu">hide</span>();
  <span class="fu">$</span>(<span class="fu">$</span>(<span class="kw">this</span>).<span class="fu">attr</span>(<span class="st">&quot;href&quot;</span>)).<span class="fu">show</span>();
  <span class="fu">$</span>(<span class="st">&quot;.active&quot;</span>).<span class="fu">removeClass</span>(<span class="st">&quot;active&quot;</span>);
  <span class="fu">$</span>(<span class="kw">this</span>).<span class="fu">parent</span>().<span class="fu">addClass</span>(<span class="st">&quot;active&quot;</span>);
  <span class="kw">return</span> <span class="kw">false</span>;
});</code></pre>
<p>Looking over the code again, you can see a few selectors that crop up again and again:</p>
<ul>
<li><code>$(&quot;.tabs&quot;)</code></li>
<li><code>$(&quot;.tabs&quot;).children(&quot;div&quot;)</code></li>
<li><code>$(&quot;.tab-link&quot;)</code></li>
</ul>
<p>So let’s make the change. We’ll replace them, but do it <em>one at a time</em>, and run the tests <em>after every change</em>. This might seem excessive, but it really is key to this process.</p>
<p>Firstly, I’ll store a reference to <code>$(&quot;.tabs&quot;)</code>:</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> tabsWrapper = <span class="fu">$</span>(<span class="st">&quot;.tabs&quot;</span>);</code></pre>
<p>And then I can replace every occurrence of <code>$(&quot;.tabs&quot;)</code> with <code>tabsWrapper</code>:</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> tabsWrapper = <span class="fu">$</span>(<span class="st">&quot;.tabs&quot;</span>);
<span class="kw">var</span> active = <span class="ot">location</span>.<span class="fu">hash</span>;
<span class="kw">if</span>(active) {
  <span class="ot">tabsWrapper</span>.<span class="fu">children</span>(<span class="st">&quot;div&quot;</span>).<span class="fu">hide</span>();
  <span class="fu">$</span>(active).<span class="fu">show</span>();
  <span class="fu">$</span>(<span class="st">&quot;.active&quot;</span>).<span class="fu">removeClass</span>(<span class="st">&quot;active&quot;</span>);
  <span class="fu">$</span>(<span class="st">&quot;.tab-link&quot;</span>).<span class="fu">each</span>(<span class="kw">function</span>() {
    <span class="kw">if</span>(<span class="fu">$</span>(<span class="kw">this</span>).<span class="fu">attr</span>(<span class="st">&quot;href&quot;</span>) === active) {
      <span class="fu">$</span>(<span class="kw">this</span>).<span class="fu">parent</span>().<span class="fu">addClass</span>(<span class="st">&quot;active&quot;</span>);
    }
  });
}
<span class="ot">tabsWrapper</span>.<span class="fu">find</span>(<span class="st">&quot;.tab-link&quot;</span>).<span class="fu">click</span>(<span class="kw">function</span>() {
  <span class="ot">tabsWrapper</span>.<span class="fu">children</span>(<span class="st">&quot;div&quot;</span>).<span class="fu">hide</span>();
  <span class="fu">$</span>(<span class="fu">$</span>(<span class="kw">this</span>).<span class="fu">attr</span>(<span class="st">&quot;href&quot;</span>)).<span class="fu">show</span>();
  <span class="fu">$</span>(<span class="st">&quot;.active&quot;</span>).<span class="fu">removeClass</span>(<span class="st">&quot;active&quot;</span>);
  <span class="fu">$</span>(<span class="kw">this</span>).<span class="fu">parent</span>().<span class="fu">addClass</span>(<span class="st">&quot;active&quot;</span>);
  <span class="kw">return</span> <span class="kw">false</span>;
});</code></pre>
<p>Now that’s done and everything is passing, I can repeat the step with <code>$(&quot;.tabs&quot;).children(&quot;div&quot;)</code>:</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> tabsWrapper = <span class="fu">$</span>(<span class="st">&quot;.tabs&quot;</span>);
<span class="kw">var</span> tabs = <span class="ot">tabsWrapper</span>.<span class="fu">children</span>(<span class="st">&quot;div&quot;</span>);
<span class="kw">var</span> active = <span class="ot">location</span>.<span class="fu">hash</span>;
<span class="kw">if</span>(active) {
  <span class="ot">tabs</span>.<span class="fu">hide</span>();
  <span class="fu">$</span>(active).<span class="fu">show</span>();
  <span class="fu">$</span>(<span class="st">&quot;.active&quot;</span>).<span class="fu">removeClass</span>(<span class="st">&quot;active&quot;</span>);
  <span class="fu">$</span>(<span class="st">&quot;.tab-link&quot;</span>).<span class="fu">each</span>(<span class="kw">function</span>() {
    <span class="kw">if</span>(<span class="fu">$</span>(<span class="kw">this</span>).<span class="fu">attr</span>(<span class="st">&quot;href&quot;</span>) === active) {
      <span class="fu">$</span>(<span class="kw">this</span>).<span class="fu">parent</span>().<span class="fu">addClass</span>(<span class="st">&quot;active&quot;</span>);
    }
  });
}
<span class="ot">tabsWrapper</span>.<span class="fu">find</span>(<span class="st">&quot;.tab-link&quot;</span>).<span class="fu">click</span>(<span class="kw">function</span>() {
  <span class="ot">tabs</span>.<span class="fu">hide</span>();
  <span class="fu">$</span>(<span class="fu">$</span>(<span class="kw">this</span>).<span class="fu">attr</span>(<span class="st">&quot;href&quot;</span>)).<span class="fu">show</span>();
  <span class="fu">$</span>(<span class="st">&quot;.active&quot;</span>).<span class="fu">removeClass</span>(<span class="st">&quot;active&quot;</span>);
  <span class="fu">$</span>(<span class="kw">this</span>).<span class="fu">parent</span>().<span class="fu">addClass</span>(<span class="st">&quot;active&quot;</span>);
  <span class="kw">return</span> <span class="kw">false</span>;
});</code></pre>
<p>And finally, deal with <code>$(&quot;.tab-link&quot;)</code>:</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> tabsWrapper = <span class="fu">$</span>(<span class="st">&quot;.tabs&quot;</span>);
<span class="kw">var</span> tabs = <span class="ot">tabsWrapper</span>.<span class="fu">children</span>(<span class="st">&quot;div&quot;</span>);
<span class="kw">var</span> tabLinks = <span class="ot">tabsWrapper</span>.<span class="fu">find</span>(<span class="st">&quot;.tab-link&quot;</span>);
<span class="kw">var</span> active = <span class="ot">location</span>.<span class="fu">hash</span>;
<span class="kw">if</span>(active) {
  <span class="ot">tabs</span>.<span class="fu">hide</span>();
  <span class="fu">$</span>(active).<span class="fu">show</span>();
  <span class="fu">$</span>(<span class="st">&quot;.active&quot;</span>).<span class="fu">removeClass</span>(<span class="st">&quot;active&quot;</span>);
  <span class="ot">tabLinks</span>.<span class="fu">each</span>(<span class="kw">function</span>() {
    <span class="kw">if</span>(<span class="fu">$</span>(<span class="kw">this</span>).<span class="fu">attr</span>(<span class="st">&quot;href&quot;</span>) === active) {
      <span class="fu">$</span>(<span class="kw">this</span>).<span class="fu">parent</span>().<span class="fu">addClass</span>(<span class="st">&quot;active&quot;</span>);
    }
  });
}
<span class="ot">tabLinks</span>.<span class="fu">click</span>(<span class="kw">function</span>() {
  <span class="ot">tabs</span>.<span class="fu">hide</span>();
  <span class="fu">$</span>(<span class="fu">$</span>(<span class="kw">this</span>).<span class="fu">attr</span>(<span class="st">&quot;href&quot;</span>)).<span class="fu">show</span>();
  <span class="fu">$</span>(<span class="st">&quot;.active&quot;</span>).<span class="fu">removeClass</span>(<span class="st">&quot;active&quot;</span>);
  <span class="fu">$</span>(<span class="kw">this</span>).<span class="fu">parent</span>().<span class="fu">addClass</span>(<span class="st">&quot;active&quot;</span>);
  <span class="kw">return</span> <span class="kw">false</span>;
});</code></pre>
<p>And now, even with just that small change in place, our code is improved. We have removed duplication, which in my opinion has given us two big improvements.</p>
<ol type="1">
<li>If any of the selectors change, or our HTML changes, we only have to change those selectors in one place, not multiple.</li>
<li>The code is clearer now. If you need to skim and quickly gain an understanding of what the code does, having well named variables in place of complex selectors helps massively.</li>
</ol>
<h2 id="more-duplication">More Duplication</h2>
<p>There’s a bit more duplication going on though. If you look through the code, you’ll see the string <code>&quot;active&quot;</code> present far too many times. What if the class we gave the active tab had to change? Right now, we’re looking at <strong>five</strong> occurences of it. Wouldn’t it be better if that was just one?</p>
<p>Let’s introduce an <code>activeClass</code> variable to deal with this:</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> tabsWrapper = <span class="fu">$</span>(<span class="st">&quot;.tabs&quot;</span>);
<span class="kw">var</span> tabs = <span class="ot">tabsWrapper</span>.<span class="fu">children</span>(<span class="st">&quot;div&quot;</span>);
<span class="kw">var</span> tabLinks = <span class="ot">tabsWrapper</span>.<span class="fu">find</span>(<span class="st">&quot;.tab-link&quot;</span>);
<span class="kw">var</span> activeClass = <span class="st">&quot;active&quot;</span>;

<span class="kw">var</span> active = <span class="ot">location</span>.<span class="fu">hash</span>;
<span class="kw">if</span>(active) {
  <span class="ot">tabs</span>.<span class="fu">hide</span>();
  <span class="fu">$</span>(active).<span class="fu">show</span>();
  <span class="fu">$</span>(<span class="st">&quot;.&quot;</span> + activeClass).<span class="fu">removeClass</span>(activeClass);
  <span class="ot">tabLinks</span>.<span class="fu">each</span>(<span class="kw">function</span>() {
    <span class="kw">if</span>(<span class="fu">$</span>(<span class="kw">this</span>).<span class="fu">attr</span>(<span class="st">&quot;href&quot;</span>) === active) {
      <span class="fu">$</span>(<span class="kw">this</span>).<span class="fu">parent</span>().<span class="fu">addClass</span>(activeClass);
    }
  });
}
<span class="ot">tabLinks</span>.<span class="fu">click</span>(<span class="kw">function</span>() {
  <span class="ot">tabs</span>.<span class="fu">hide</span>();
  <span class="fu">$</span>(<span class="fu">$</span>(<span class="kw">this</span>).<span class="fu">attr</span>(<span class="st">&quot;href&quot;</span>)).<span class="fu">show</span>();
  <span class="fu">$</span>(<span class="st">&quot;.&quot;</span> + activeClass).<span class="fu">removeClass</span>(activeClass);
  <span class="fu">$</span>(<span class="kw">this</span>).<span class="fu">parent</span>().<span class="fu">addClass</span>(activeClass);
  <span class="kw">return</span> <span class="kw">false</span>;
});</code></pre>
<p>That’s a good step to take, but in the midst of doing this you might have spotted some more duplication. Take a look at these two code blocks. They look pretty similar to me:</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="fu">$</span>(<span class="st">&quot;.&quot;</span> + activeClass).<span class="fu">removeClass</span>(activeClass);
<span class="ot">tabLinks</span>.<span class="fu">each</span>(<span class="kw">function</span>() {
  <span class="kw">if</span>(<span class="fu">$</span>(<span class="kw">this</span>).<span class="fu">attr</span>(<span class="st">&quot;href&quot;</span>) === active) {
    <span class="fu">$</span>(<span class="kw">this</span>).<span class="fu">parent</span>().<span class="fu">addClass</span>(activeClass);
  }
});</code></pre>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="fu">$</span>(<span class="st">&quot;.&quot;</span> + activeClass).<span class="fu">removeClass</span>(activeClass);
<span class="fu">$</span>(<span class="kw">this</span>).<span class="fu">parent</span>().<span class="fu">addClass</span>(activeClass);</code></pre>
<p>The first is slightly different, because it has to loop over the links to find the right element to work with, but both of these blocks are performing the same piece of work:</p>
<ol type="1">
<li>Find the current element with the active class, and remove the active class.</li>
<li>Take the new active link’s parent, and add the active class.</li>
</ol>
<p>When we have more than one block of code doing the same thing we can abstract them out into a function. Let’s do that now:</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> activateLink = <span class="kw">function</span>(elem) {
  <span class="fu">$</span>(<span class="st">&quot;.&quot;</span> + activeClass).<span class="fu">removeClass</span>(activeClass);
  <span class="fu">$</span>(elem).<span class="fu">addClass</span>(activeClass);
};</code></pre>
<p>The <code>activateLink</code> function takes an element and adds the active class to it once it’s first removed the active class from any other element that might have it. Now we have this function, we can use it in place of the code we looked at previously. We’ll do this change one at a time. Firstly, we can edit the code within the <code>tabLinks.click</code> handler:</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> tabsWrapper = <span class="fu">$</span>(<span class="st">&quot;.tabs&quot;</span>);
<span class="kw">var</span> tabs = <span class="ot">tabsWrapper</span>.<span class="fu">children</span>(<span class="st">&quot;div&quot;</span>);
<span class="kw">var</span> tabLinks = <span class="ot">tabsWrapper</span>.<span class="fu">find</span>(<span class="st">&quot;.tab-link&quot;</span>);
<span class="kw">var</span> activeClass = <span class="st">&quot;active&quot;</span>;
<span class="kw">var</span> activateLink = <span class="kw">function</span>(elem) {
  <span class="fu">$</span>(<span class="st">&quot;.&quot;</span> + activeClass).<span class="fu">removeClass</span>(activeClass);
  <span class="fu">$</span>(elem).<span class="fu">addClass</span>(activeClass);
};

<span class="kw">var</span> active = <span class="ot">location</span>.<span class="fu">hash</span>;
<span class="kw">if</span>(active) {
  <span class="ot">tabs</span>.<span class="fu">hide</span>();
  <span class="fu">$</span>(active).<span class="fu">show</span>();
  <span class="fu">$</span>(<span class="st">&quot;.&quot;</span> + activeClass).<span class="fu">removeClass</span>(activeClass);
  <span class="ot">tabLinks</span>.<span class="fu">each</span>(<span class="kw">function</span>() {
    <span class="kw">if</span>(<span class="fu">$</span>(<span class="kw">this</span>).<span class="fu">attr</span>(<span class="st">&quot;href&quot;</span>) === active) {
      <span class="fu">$</span>(<span class="kw">this</span>).<span class="fu">parent</span>().<span class="fu">addClass</span>(activeClass);
    }
  });
}
<span class="ot">tabLinks</span>.<span class="fu">click</span>(<span class="kw">function</span>() {
  <span class="ot">tabs</span>.<span class="fu">hide</span>();
  <span class="fu">$</span>(<span class="fu">$</span>(<span class="kw">this</span>).<span class="fu">attr</span>(<span class="st">&quot;href&quot;</span>)).<span class="fu">show</span>();
  <span class="fu">activateLink</span>(<span class="fu">$</span>(<span class="kw">this</span>).<span class="fu">parent</span>());
  <span class="kw">return</span> <span class="kw">false</span>;
});</code></pre>
<p>Now all we have to do is pass <code>$(this).parent()</code>, which is the element we want to gain the active class, into our <code>activateLink</code> function, and it does the rest. We can now swap our function in in place of the code in the <code>if(active) {}</code> block:</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> tabsWrapper = <span class="fu">$</span>(<span class="st">&quot;.tabs&quot;</span>);
<span class="kw">var</span> tabs = <span class="ot">tabsWrapper</span>.<span class="fu">children</span>(<span class="st">&quot;div&quot;</span>);
<span class="kw">var</span> tabLinks = <span class="ot">tabsWrapper</span>.<span class="fu">find</span>(<span class="st">&quot;.tab-link&quot;</span>);
<span class="kw">var</span> activeClass = <span class="st">&quot;active&quot;</span>;
<span class="kw">var</span> activateLink = <span class="kw">function</span>(elem) {
  <span class="fu">$</span>(<span class="st">&quot;.&quot;</span> + activeClass).<span class="fu">removeClass</span>(activeClass);
  <span class="fu">$</span>(elem).<span class="fu">addClass</span>(activeClass);
};

<span class="kw">var</span> active = <span class="ot">location</span>.<span class="fu">hash</span>;
<span class="kw">if</span>(active) {
  <span class="ot">tabs</span>.<span class="fu">hide</span>();
  <span class="fu">$</span>(active).<span class="fu">show</span>();
  <span class="ot">tabLinks</span>.<span class="fu">each</span>(<span class="kw">function</span>() {
    <span class="kw">if</span>(<span class="fu">$</span>(<span class="kw">this</span>).<span class="fu">attr</span>(<span class="st">&quot;href&quot;</span>) === active) {
      <span class="fu">activateLink</span>(<span class="fu">$</span>(<span class="kw">this</span>).<span class="fu">parent</span>());
    }
  });
}
<span class="ot">tabLinks</span>.<span class="fu">click</span>(<span class="kw">function</span>() {
  <span class="ot">tabs</span>.<span class="fu">hide</span>();
  <span class="fu">$</span>(<span class="fu">$</span>(<span class="kw">this</span>).<span class="fu">attr</span>(<span class="st">&quot;href&quot;</span>)).<span class="fu">show</span>();
  <span class="fu">activateLink</span>(<span class="fu">$</span>(<span class="kw">this</span>).<span class="fu">parent</span>());
  <span class="kw">return</span> <span class="kw">false</span>;
});</code></pre>
<p>Abstracting code out into functions is one of the easiest and most effective ways to make a block of code more maintainable. Functions are inherently self documenting, a well named function can tell you in one quick skim exactly what its function is, and what it does. As a new developer coming to the above block of code, I can understand the <code>activateLink</code> function’s effect <em>without looking at the code within it</em>. Being able to skim a block of code and gain an understanding without having to look at detailed implementation is a fantastic thing as a developer.</p>
<h2 id="step-back">Step Back</h2>
<p>We are far from done with these tabs, but I want you to notice how, even after just a couple of small changes, the code is now already in an improved position than when we picked it up. We have removed duplication of selectors and code, and made the code more self documenting and readable along the way. When refactoring, you should be in a position to stop the refactoring at any point, and move onto something else. If this was a real project, and suddenly I was called to an urgent bug in another project, I could commit this code now and still have improved it. You should never find yourself in such a mess that you can’t put the code down and come back later. This is vital to successful refactorings: keep them small and contained.</p>
<h2 id="higher-level-duplication">Higher level duplication</h2>
<p>The code we’ve been working with has two blocks:</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">if</span>(active) {
  <span class="co">// do tab things</span>
};

<span class="ot">tabLinks</span>.<span class="fu">click</span>(<span class="kw">function</span>() {
  <span class="co">// do tab things</span>
};</code></pre>
<p>Although it doesn’t look like it at a glance, there’s a lot of duplication going on - both those blocks of code perform basically the same task. This can be sometimes hard to spot, as it can be hidden behind code that doesn’t immediately look the same.</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> tabsWrapper = <span class="fu">$</span>(<span class="st">&quot;.tabs&quot;</span>);
<span class="kw">var</span> tabs = <span class="ot">tabsWrapper</span>.<span class="fu">children</span>(<span class="st">&quot;div&quot;</span>);
<span class="kw">var</span> tabLinks = <span class="ot">tabsWrapper</span>.<span class="fu">find</span>(<span class="st">&quot;.tab-link&quot;</span>);
<span class="kw">var</span> activeClass = <span class="st">&quot;active&quot;</span>;
<span class="kw">var</span> activateLink = <span class="kw">function</span>(elem) {
  <span class="fu">$</span>(<span class="st">&quot;.&quot;</span> + activeClass).<span class="fu">removeClass</span>(activeClass);
  <span class="fu">$</span>(elem).<span class="fu">addClass</span>(activeClass);
};

<span class="kw">var</span> active = <span class="ot">location</span>.<span class="fu">hash</span>;
<span class="kw">if</span>(active) {
  <span class="ot">tabs</span>.<span class="fu">hide</span>();
  <span class="fu">$</span>(active).<span class="fu">show</span>();
  <span class="ot">tabLinks</span>.<span class="fu">each</span>(<span class="kw">function</span>() {
    <span class="kw">if</span>(<span class="fu">$</span>(<span class="kw">this</span>).<span class="fu">attr</span>(<span class="st">&quot;href&quot;</span>) === active) {
      <span class="fu">activateLink</span>(<span class="fu">$</span>(<span class="kw">this</span>).<span class="fu">parent</span>());
    }
  });
}
<span class="ot">tabLinks</span>.<span class="fu">click</span>(<span class="kw">function</span>() {
  <span class="ot">tabs</span>.<span class="fu">hide</span>();
  <span class="fu">$</span>(<span class="fu">$</span>(<span class="kw">this</span>).<span class="fu">attr</span>(<span class="st">&quot;href&quot;</span>)).<span class="fu">show</span>();
  <span class="fu">activateLink</span>(<span class="fu">$</span>(<span class="kw">this</span>).<span class="fu">parent</span>());
  <span class="kw">return</span> <span class="kw">false</span>;
});</code></pre>
<p>Now I’ve given you the primer, take another look over the code above. Notice how both blocks do the same thing:</p>
<ul>
<li>hide all the tabs</li>
<li>find and show a specific tab</li>
<li>update the link for that tab with a new class</li>
</ul>
<p>The duplication is obscured somewhat because of the need for the <code>tabLinks.each</code> in the first block, but this doesn’t mean that we can’t abstract that duplication into a function.</p>
<p>Sticking with our mantra of making small steps, let’s first make a function that shows a specific tab. Sticking with the naming conventions, we’ll call it <code>activateTab</code>:</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> activateTab = <span class="kw">function</span>(tabSelector) {
  <span class="ot">tabs</span>.<span class="fu">hide</span>();
  <span class="fu">$</span>(tabSelector).<span class="fu">show</span>();
};</code></pre>
<p>This function takes a selector and shows it, after hiding all of the tabs first. We can now use this in both the <code>if(active)</code> block and in the event handler:</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> tabsWrapper = <span class="fu">$</span>(<span class="st">&quot;.tabs&quot;</span>);
<span class="kw">var</span> tabs = <span class="ot">tabsWrapper</span>.<span class="fu">children</span>(<span class="st">&quot;div&quot;</span>);
<span class="kw">var</span> tabLinks = <span class="ot">tabsWrapper</span>.<span class="fu">find</span>(<span class="st">&quot;.tab-link&quot;</span>);
<span class="kw">var</span> activeClass = <span class="st">&quot;active&quot;</span>;

<span class="kw">var</span> activateLink = <span class="kw">function</span>(elem) {
  <span class="fu">$</span>(<span class="st">&quot;.&quot;</span> + activeClass).<span class="fu">removeClass</span>(activeClass);
  <span class="fu">$</span>(elem).<span class="fu">addClass</span>(activeClass);
};

<span class="kw">var</span> activateTab = <span class="kw">function</span>(tabSelector) {
  <span class="ot">tabs</span>.<span class="fu">hide</span>();
  <span class="fu">$</span>(tabSelector).<span class="fu">show</span>();
};

<span class="kw">var</span> active = <span class="ot">location</span>.<span class="fu">hash</span>;
<span class="kw">if</span>(active) {
  <span class="fu">activateTab</span>(active);
  <span class="ot">tabLinks</span>.<span class="fu">each</span>(<span class="kw">function</span>() {
    <span class="kw">if</span>(<span class="fu">$</span>(<span class="kw">this</span>).<span class="fu">attr</span>(<span class="st">&quot;href&quot;</span>) === active) {
      <span class="fu">activateLink</span>(<span class="fu">$</span>(<span class="kw">this</span>).<span class="fu">parent</span>());
    }
  });
}
<span class="ot">tabLinks</span>.<span class="fu">click</span>(<span class="kw">function</span>() {
  <span class="fu">activateTab</span>(<span class="fu">$</span>(<span class="kw">this</span>).<span class="fu">attr</span>(<span class="st">&quot;href&quot;</span>));
  <span class="fu">activateLink</span>(<span class="fu">$</span>(<span class="kw">this</span>).<span class="fu">parent</span>());
  <span class="kw">return</span> <span class="kw">false</span>;
});</code></pre>
<p>We’re really motoring now. Notice how the tabLinks event handler simply calls two other functions, and has very little in it. This is a good sign that we’re on the right tracks. <a href="http://codeulate.com/">Ben Orenstein</a>, a developer who speaks a huge amount on refactoring, says that a function with one line inside is superior to a function with two lines, which in turn is superior to a function with three lines, and so on. <a href="http://www.sandimetz.com/">Sandi Metz</a>, a well known Ruby developer, defined a <a href="http://robots.thoughtbot.com/sandi-metz-rules-for-developers">set of rules</a> that help when building large projects, one of which is: “Methods can be no longer than five lines of code.”. Regardless of if you think five is a good or bad number for that rule, the point stands: short, small functions are nearly always preferable to large ones. Keep functions small and compose larger functions out of calling lots of little ones.</p>
<p>Before we continue, notice again how if we wanted to stop now, we could. It’s so important to not let yourself get down a huge rabbit hole of refactoring.</p>
<h2 id="merging-the-branches">Merging the branches</h2>
<p>Right now we have two branches in our code, the <code>if(active)</code> part and the event handler. I’d really like to try and get these into one, or at least make the branches as small as possible. Right now they still have duplication, they both call <code>activateTab</code> and <code>activateLink</code>. I’d really like to abstract that out into another function, but right now the obvious step isn’t that obvious. Sometimes you’ll reach a point like this when you’re coding, where you know what you need to do or want to do, but the step isn’t obvious. Often you’ll have to make another change, to make the new change easier. In their book <a href="http://refactoring.com/">Refactoring</a>, Martin Fowler and Kent Beck put this nicely:</p>
<blockquote>
<p>When you find you have to add a feature to a program, and the program’s code is not structured in a convenient way to add the feature, first refactor the program to make it easy to add the feature, then add the feature.</p>
</blockquote>
<p>Although this quote talks about new features, what it effectively says is that if you need to make a change, but that change is proving tough to make, make other changes such that your original change is easy.</p>
<p>I realised after some thinking that the bit of code making this change difficult is this bit:</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="ot">tabLinks</span>.<span class="fu">each</span>(<span class="kw">function</span>() {
  <span class="kw">if</span>(<span class="fu">$</span>(<span class="kw">this</span>).<span class="fu">attr</span>(<span class="st">&quot;href&quot;</span>) === active) {
    <span class="fu">activateLink</span>(<span class="fu">$</span>(<span class="kw">this</span>).<span class="fu">parent</span>());
  }
});</code></pre>
<p>The fact that we have to loop over means we can’t just abstract out as easily. Instead of the <code>each</code>, we can instead use jQuery’s <code>filter</code> method:</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> link = <span class="ot">tabLinks</span>.<span class="fu">filter</span>(<span class="kw">function</span>() {
  <span class="kw">return</span> <span class="fu">$</span>(<span class="kw">this</span>).<span class="fu">attr</span>(<span class="st">&quot;href&quot;</span>) === active;
}).<span class="fu">parent</span>();
<span class="fu">activateLink</span>(link);</code></pre>
<p>We now filter over the tab links, looking for the one that matches the <code>active</code> hash, and get at the item that way instead. I can store the result of that to a variable, and then pass <code>activateLink</code> that element. Adding that change into our code gives us:</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> tabsWrapper = <span class="fu">$</span>(<span class="st">&quot;.tabs&quot;</span>);
<span class="kw">var</span> tabs = <span class="ot">tabsWrapper</span>.<span class="fu">children</span>(<span class="st">&quot;div&quot;</span>);
<span class="kw">var</span> tabLinks = <span class="ot">tabsWrapper</span>.<span class="fu">find</span>(<span class="st">&quot;.tab-link&quot;</span>);
<span class="kw">var</span> activeClass = <span class="st">&quot;active&quot;</span>;

<span class="kw">var</span> activateLink = <span class="kw">function</span>(elem) {
  <span class="fu">$</span>(<span class="st">&quot;.&quot;</span> + activeClass).<span class="fu">removeClass</span>(activeClass);
  <span class="fu">$</span>(elem).<span class="fu">addClass</span>(activeClass);
};

<span class="kw">var</span> activateTab = <span class="kw">function</span>(tabSelector) {
  <span class="ot">tabs</span>.<span class="fu">hide</span>();
  <span class="fu">$</span>(tabSelector).<span class="fu">show</span>();
};

<span class="kw">var</span> active = <span class="ot">location</span>.<span class="fu">hash</span>;
<span class="kw">if</span>(active) {
  <span class="fu">activateTab</span>(active);
  <span class="kw">var</span> link = <span class="ot">tabLinks</span>.<span class="fu">filter</span>(<span class="kw">function</span>() {
    <span class="kw">return</span> <span class="fu">$</span>(<span class="kw">this</span>).<span class="fu">attr</span>(<span class="st">&quot;href&quot;</span>) === active;
  }).<span class="fu">parent</span>();
  <span class="fu">activateLink</span>(link);
}
<span class="ot">tabLinks</span>.<span class="fu">click</span>(<span class="kw">function</span>() {
  <span class="fu">activateTab</span>(<span class="fu">$</span>(<span class="kw">this</span>).<span class="fu">attr</span>(<span class="st">&quot;href&quot;</span>));
  <span class="fu">activateLink</span>(<span class="fu">$</span>(<span class="kw">this</span>).<span class="fu">parent</span>());
  <span class="kw">return</span> <span class="kw">false</span>;
});</code></pre>
<p>Now, to see where the next change will come from, we need to examine a bit more closely the <code>activateLink</code> and <code>activateTab</code> function. Ideally, I’d like to encapsulate these into another function, but to do that we need to see what each function needs as a parameter. <code>activateTab</code> just takes a selector and uses that to hide and show what’s required, but <code>activateLink</code> actually takes in an element. However, if you look closely, you’ll note that there is a relationship between the <code>activateTab</code> parameter and the <code>activateLink</code> parameter. The <code>activateLink</code> is the parent of the element whose selector we pass into <code>activateTab</code>. So why don’t we pass the selector into <code>activateLink</code>, and let it find the exact element it needs?</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> activateLink = <span class="kw">function</span>(selector) {
  <span class="fu">$</span>(<span class="st">&quot;.&quot;</span> + activeClass).<span class="fu">removeClass</span>(activeClass);
  <span class="kw">var</span> elem = <span class="ot">tabLinks</span>.<span class="fu">filter</span>(<span class="kw">function</span>() {
    <span class="kw">return</span> <span class="fu">$</span>(<span class="kw">this</span>).<span class="fu">attr</span>(<span class="st">&quot;href&quot;</span>) === selector;
  }).<span class="fu">parent</span>();
  <span class="fu">$</span>(elem).<span class="fu">addClass</span>(activeClass);
};</code></pre>
<p>With that change, suddenly we can rewrite the two branches of our code to look very similar indeed:</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">if</span>(active) {
  <span class="fu">activateTab</span>(active);
  <span class="fu">activateLink</span>(active);
}
<span class="ot">tabLinks</span>.<span class="fu">click</span>(<span class="kw">function</span>() {
  <span class="fu">activateTab</span>(<span class="fu">$</span>(<span class="kw">this</span>).<span class="fu">attr</span>(<span class="st">&quot;href&quot;</span>));
  <span class="fu">activateLink</span>(<span class="fu">$</span>(<span class="kw">this</span>).<span class="fu">attr</span>(<span class="st">&quot;href&quot;</span>));
  <span class="kw">return</span> <span class="kw">false</span>;
});</code></pre>
<p>Now we’ve achieved what we wanted; by performing some intermediate refactorings we now are in a position to deal with the duplication we have in the two branches.</p>
<h2 id="one-method-to-rule-them-all">One method to rule them all</h2>
<p>We’re going to extract a new method, called <code>transition</code>, which will take the selector of the active tab in as its argument, and perform the tasks required. The <code>transition</code> method is very simple, it just hands off to <code>activateTab</code> and <code>activateLink</code>:</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> transition = <span class="kw">function</span>(selector) {
  <span class="fu">activateTab</span>(selector);
  <span class="fu">activateLink</span>(selector);
};</code></pre>
<p>And now we can use that method in our code. In reality I did make this change in two steps, inserting one usage at a time, but I think you get the picture, so I’ll show it here as one change. Our new code looks like so:</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> tabsWrapper = <span class="fu">$</span>(<span class="st">&quot;.tabs&quot;</span>);
<span class="kw">var</span> tabs = <span class="ot">tabsWrapper</span>.<span class="fu">children</span>(<span class="st">&quot;div&quot;</span>);
<span class="kw">var</span> tabLinks = <span class="ot">tabsWrapper</span>.<span class="fu">find</span>(<span class="st">&quot;.tab-link&quot;</span>);
<span class="kw">var</span> activeClass = <span class="st">&quot;active&quot;</span>;

<span class="kw">var</span> activateLink = <span class="kw">function</span>(elem) {
  <span class="fu">$</span>(<span class="st">&quot;.&quot;</span> + activeClass).<span class="fu">removeClass</span>(activeClass);
  <span class="fu">$</span>(elem).<span class="fu">addClass</span>(activeClass);
};

<span class="kw">var</span> activateTab = <span class="kw">function</span>(tabSelector) {
  <span class="ot">tabs</span>.<span class="fu">hide</span>();
  <span class="fu">$</span>(tabSelector).<span class="fu">show</span>();
};

<span class="kw">var</span> transition = <span class="kw">function</span>(selector) {
  <span class="fu">activateTab</span>(selector);
  <span class="fu">activateLink</span>(selector);
};

<span class="kw">var</span> active = <span class="ot">location</span>.<span class="fu">hash</span>;
<span class="kw">if</span>(active) {
  <span class="fu">transition</span>(active);
}
<span class="ot">tabLinks</span>.<span class="fu">click</span>(<span class="kw">function</span>() {
  <span class="fu">transition</span>(<span class="fu">$</span>(<span class="kw">this</span>).<span class="fu">attr</span>(<span class="st">&quot;href&#39;));</span>
  <span class="kw">return</span> <span class="kw">false</span>;
});</code></pre>
<h2 id="reflection">Reflection</h2>
<p>There’s certainly more you could do with this code, and it’s also far from being the best implementation of tabs around, but I hope you agree with me that the end result is now much nicer than the one we had at the beginning, which is printed below for you to compare.</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> active = <span class="ot">location</span>.<span class="fu">hash</span>;
<span class="kw">if</span>(active) {
  <span class="fu">$</span>(<span class="st">&quot;.tabs&quot;</span>).<span class="fu">children</span>(<span class="st">&quot;div&quot;</span>).<span class="fu">hide</span>();
  <span class="fu">$</span>(active).<span class="fu">show</span>();
  <span class="fu">$</span>(<span class="st">&quot;.active&quot;</span>).<span class="fu">removeClass</span>(<span class="st">&quot;active&quot;</span>);
  <span class="fu">$</span>(<span class="st">&quot;.tab-link&quot;</span>).<span class="fu">each</span>(<span class="kw">function</span>() {
    <span class="kw">if</span>(<span class="fu">$</span>(<span class="kw">this</span>).<span class="fu">attr</span>(<span class="st">&quot;href&quot;</span>) === active) {
      <span class="fu">$</span>(<span class="kw">this</span>).<span class="fu">parent</span>().<span class="fu">addClass</span>(<span class="st">&quot;active&quot;</span>);
    }
  });
}
<span class="fu">$</span>(<span class="st">&quot;.tabs&quot;</span>).<span class="fu">find</span>(<span class="st">&quot;.tab-link&quot;</span>).<span class="fu">click</span>(<span class="kw">function</span>() {
  <span class="fu">$</span>(<span class="st">&quot;.tabs&quot;</span>).<span class="fu">children</span>(<span class="st">&quot;div&quot;</span>).<span class="fu">hide</span>();
  <span class="fu">$</span>(<span class="fu">$</span>(<span class="kw">this</span>).<span class="fu">attr</span>(<span class="st">&quot;href&quot;</span>)).<span class="fu">show</span>();
  <span class="fu">$</span>(<span class="st">&quot;.active&quot;</span>).<span class="fu">removeClass</span>(<span class="st">&quot;active&quot;</span>);
  <span class="fu">$</span>(<span class="kw">this</span>).<span class="fu">parent</span>().<span class="fu">addClass</span>(<span class="st">&quot;active&quot;</span>);
  <span class="kw">return</span> <span class="kw">false</span>;
});</code></pre>
<p>By removing duplication and making things clearer, we’ve ended up with a solution that is more readable, self documenting and maintainable. Notice how at first glance the two different sections of the code looked very different, but after some initial refactorings we found them actually to be near identical. This is a common occurrence - often a refactor will open up new possibilities and ways of working, which is another reason to keep your refactorings small and your mind open - an improvement might not be immediately obvious at the beginning.</p>
<h1 id="tale-2-cringey-carousels">Tale 2: Cringey Carousels</h1>
<p>In this chapter I want to talk about the value of some “quick wins” - very simple refactorings that, when applied to a codebase, will hugely improve the readability and maintainability of the project, at very little time and effort to yourself. You may find yourself too busy to fully refactor a huge method, but with these small steps you can make large gains quickly.</p>
<h2 id="the-carousel">The Carousel</h2>
<p>I’ve put together a simple enough jQuery Carousel which boasts the following feature set:</p>
<ul>
<li>‘Left’ and ‘Right’ links to navigate the carousel</li>
<li>Moves automatically every 10 seconds</li>
<li>If you hit the page with a hash such as <code>#image2</code>, it will move the carousel to that image.</li>
</ul>
<p>Hardily a fully featured carousel but it covers the basic functionality of most carousels I’ve seen, and those features provide enough scope for me to produce bad code that we can tidy. Take a deep breath and we’ll dive in.</p>
<p>First, there’s the HTML. Pretty simple and standard really:</p>
<pre class="sourceCode html"><code class="sourceCode html"><span class="dt">&lt;!DOCTYPE </span>html<span class="dt">&gt;</span>
<span class="kw">&lt;html&gt;</span>
<span class="kw">&lt;head&gt;</span>
  <span class="kw">&lt;title&gt;&lt;/title&gt;</span>
  <span class="kw">&lt;link</span><span class="ot"> rel=</span><span class="st">&quot;stylesheet&quot;</span><span class="ot"> href=</span><span class="st">&quot;css/style.css&quot;</span><span class="kw">&gt;</span>
  <span class="kw">&lt;script</span><span class="ot"> src=</span><span class="st">&quot;js/jquery.min.js&quot;</span><span class="kw">&gt;&lt;/script&gt;</span>
  <span class="kw">&lt;script</span><span class="ot"> src=</span><span class="st">&quot;js/app.js&quot;</span><span class="kw">&gt;&lt;/script&gt;</span>
<span class="kw">&lt;/head&gt;</span>
<span class="kw">&lt;body&gt;</span>
  <span class="kw">&lt;div</span><span class="ot"> class=</span><span class="st">&quot;wrapper&quot;</span><span class="kw">&gt;</span>
    <span class="kw">&lt;ul&gt;</span>
      <span class="kw">&lt;li&gt;&lt;img</span><span class="ot"> src=</span><span class="st">&quot;http://placekitten.com/300/300&quot;</span><span class="ot"> alt=</span><span class="st">&quot;Kitten&quot;</span> <span class="kw">/&gt;&lt;/li&gt;</span>
      <span class="kw">&lt;li&gt;&lt;img</span><span class="ot"> src=</span><span class="st">&quot;http://placekitten.com/300/300&quot;</span><span class="ot"> alt=</span><span class="st">&quot;Kitten&quot;</span> <span class="kw">/&gt;&lt;/li&gt;</span>
      <span class="kw">&lt;li&gt;&lt;img</span><span class="ot"> src=</span><span class="st">&quot;http://placekitten.com/300/300&quot;</span><span class="ot"> alt=</span><span class="st">&quot;Kitten&quot;</span> <span class="kw">/&gt;&lt;/li&gt;</span>
      <span class="kw">&lt;li&gt;&lt;img</span><span class="ot"> src=</span><span class="st">&quot;http://placekitten.com/300/300&quot;</span><span class="ot"> alt=</span><span class="st">&quot;Kitten&quot;</span> <span class="kw">/&gt;&lt;/li&gt;</span>
      <span class="kw">&lt;li&gt;&lt;img</span><span class="ot"> src=</span><span class="st">&quot;http://placekitten.com/300/300&quot;</span><span class="ot"> alt=</span><span class="st">&quot;Kitten&quot;</span> <span class="kw">/&gt;&lt;/li&gt;</span>
    <span class="kw">&lt;/ul&gt;</span>
    <span class="kw">&lt;div</span><span class="ot"> class=</span><span class="st">&quot;controls&quot;</span><span class="kw">&gt;</span>
      <span class="kw">&lt;a</span><span class="ot"> href=</span><span class="st">&quot;#&quot;</span><span class="ot"> class=</span><span class="st">&quot;left&quot;</span><span class="kw">&gt;</span>Left<span class="kw">&lt;/a&gt;</span>
      <span class="kw">&lt;a</span><span class="ot"> href=</span><span class="st">&quot;#&quot;</span><span class="ot"> class=</span><span class="st">&quot;right&quot;</span><span class="kw">&gt;</span>Right<span class="kw">&lt;/a&gt;</span>
      <span class="kw">&lt;span&gt;&lt;/span&gt;</span>
    <span class="kw">&lt;/div&gt;</span>
  <span class="kw">&lt;/div&gt;</span>
<span class="kw">&lt;/body&gt;</span>
<span class="kw">&lt;/html&gt;</span></code></pre>
<p>There is also some CSS applied to make it look good, but we won’t be focusing on that.</p>
<p>Finally, the JavaScript:</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="fu">$</span>(<span class="kw">function</span>() {
  <span class="kw">if</span>(<span class="ot">location</span>.<span class="fu">hash</span> &amp;&amp; <span class="ot">location</span>.<span class="ot">hash</span>.<span class="fu">indexOf</span>(<span class="st">&quot;image&quot;</span>) &gt; -<span class="dv">1</span>) {
    <span class="kw">var</span> number = <span class="fu">parseInt</span>(<span class="ot">location</span>.<span class="ot">hash</span>.<span class="fu">charAt</span>(<span class="ot">location</span>.<span class="ot">hash</span>.<span class="fu">length</span> -<span class="dv">1</span>));
    <span class="fu">$</span>(<span class="st">&quot;ul&quot;</span>).<span class="fu">animate</span>({
      <span class="st">&quot;margin-left&quot;</span>: number * -<span class="dv">300</span>
    }, <span class="kw">function</span>() {
      currentImage = number;
      <span class="fu">$</span>(<span class="st">&quot;.controls span&quot;</span>).<span class="fu">text</span>(<span class="st">&quot;Current: &quot;</span> + (currentImage + <span class="dv">1</span>));
    });
  }
  <span class="kw">var</span> timeout = <span class="fu">setTimeout</span>(<span class="kw">function</span>() {
    <span class="fu">$</span>(<span class="st">&quot;.left&quot;</span>).<span class="fu">trigger</span>(<span class="st">&quot;click&quot;</span>);
  }, <span class="dv">10000</span>);

  <span class="kw">var</span> currentImage = <span class="dv">0</span>;
  <span class="fu">$</span>(<span class="st">&quot;.left&quot;</span>).<span class="fu">click</span>(<span class="kw">function</span>() {
    <span class="fu">clearTimeout</span>(timeout);
    <span class="kw">if</span>(currentImage == <span class="fu">$</span>(<span class="st">&quot;li&quot;</span>).<span class="fu">length</span> - <span class="dv">1</span>) {
      <span class="fu">$</span>(<span class="st">&quot;ul&quot;</span>).<span class="fu">animate</span>({
        <span class="st">&quot;margin-left&quot;</span>: <span class="dv">0</span>
      }, <span class="kw">function</span>() {
        currentImage = <span class="dv">0</span>;
        <span class="fu">$</span>(<span class="st">&quot;.controls span&quot;</span>).<span class="fu">text</span>(<span class="st">&quot;Current: &quot;</span> + (currentImage + <span class="dv">1</span>));
      });
    } <span class="kw">else</span> {
      <span class="fu">$</span>(<span class="st">&quot;ul&quot;</span>).<span class="fu">animate</span>({
        <span class="st">&quot;margin-left&quot;</span>: <span class="st">&quot;-=300px&quot;</span>
      }, <span class="kw">function</span>() {
        currentImage+=<span class="dv">1</span>;
        <span class="fu">$</span>(<span class="st">&quot;.controls span&quot;</span>).<span class="fu">text</span>(<span class="st">&quot;Current: &quot;</span> + (currentImage + <span class="dv">1</span>));
      });
    }
    timeout = <span class="fu">setTimeout</span>(<span class="kw">function</span>() {
      <span class="fu">$</span>(<span class="st">&quot;.left&quot;</span>).<span class="fu">trigger</span>(<span class="st">&quot;click&quot;</span>);
    }, <span class="dv">10000</span>);
    <span class="kw">return</span> <span class="kw">false</span>;
  });

  <span class="fu">$</span>(<span class="st">&quot;.right&quot;</span>).<span class="fu">click</span>(<span class="kw">function</span>() {
    <span class="fu">clearTimeout</span>(timeout);
    <span class="kw">if</span>(currentImage == <span class="dv">0</span>) {
      <span class="fu">$</span>(<span class="st">&quot;ul&quot;</span>).<span class="fu">animate</span>({
        <span class="st">&quot;margin-left&quot;</span>: (<span class="fu">$</span>(<span class="st">&quot;li&quot;</span>).<span class="fu">length</span> - <span class="dv">1</span>) * -<span class="dv">300</span>
      }, <span class="kw">function</span>() {
        currentImage = <span class="fu">$</span>(<span class="st">&quot;li&quot;</span>).<span class="fu">length</span> - <span class="dv">1</span>;
        <span class="fu">$</span>(<span class="st">&quot;.controls span&quot;</span>).<span class="fu">text</span>(<span class="st">&quot;Current: &quot;</span> + (currentImage + <span class="dv">1</span>));
      });
    } <span class="kw">else</span> {
      <span class="fu">$</span>(<span class="st">&quot;ul&quot;</span>).<span class="fu">animate</span>({
        <span class="st">&quot;margin-left&quot;</span>: <span class="st">&quot;+=300px&quot;</span>
      }, <span class="kw">function</span>() {
        currentImage-=<span class="dv">1</span>;
        <span class="fu">$</span>(<span class="st">&quot;.controls span&quot;</span>).<span class="fu">text</span>(<span class="st">&quot;Current: &quot;</span> + (currentImage + <span class="dv">1</span>));
      });
    }
    timeout = <span class="fu">setTimeout</span>(<span class="kw">function</span>() {
      <span class="fu">$</span>(<span class="st">&quot;.left&quot;</span>).<span class="fu">trigger</span>(<span class="st">&quot;click&quot;</span>);
    }, <span class="dv">10000</span>);
    <span class="kw">return</span> <span class="kw">false</span>;
  });
});</code></pre>
<p>I think JavaScript like this is JavaScript we’ve all written before. I know I have. Take a moment to study it and see if you can spot the problems with it. There’s some much larger problems that we won’t look at right now, but you should be able to spot a lot of “quick wins” that we can take care of right here and now. I highly recommend noting down on paper a list of all the problems you spot and comparing them to the one I came up with below, to see what you might miss and to see if you identify things I didn’t.</p>
<p>I’ve split my list of problems into two parts. Firstly, the big problems:</p>
<ul>
<li><strong>Duplication</strong>. the same block of code is used multiple times to animate the margin. Additionally, the event handlers for the click on <code>.left</code> and <code>.right</code> are almost identical too, along with numerous others.</li>
<li><strong>Bad Selectors</strong>. There’s very little in the way of contextual selectors. What I mean by this is the selectors are too general, <code>$(&quot;ul&quot;)</code> for example.</li>
<li><strong>Magic Values</strong>. A new developer reading this would have no idea why the number <code>300</code> crops up so regularly. Nor would it be immediately obvious why this was sometimes negative 300.</li>
<li><strong>Reusing selectors</strong>. By my count there are <strong>15</strong> invocations of <code>$(thing)</code>, often with the same thing passed in as on a line previous.</li>
<li><strong>document ready abuse</strong>. All the code is within one <code>$(function() {})</code> block.</li>
</ul>
<p>Remember, <code>$(function() {})</code> is shorthand for <code>$(document).ready(function() {})</code>. Whenever you pass a function into <code>$()</code>, jQuery will presume you want it to run only when the document is ready.</p>
<p>And some things we can clean up immediately:</p>
<ul>
<li>Use of <code>return false</code>. Generally passing the event into the handler function and calling <code>e.preventDefault()</code> is preferred (I’ll discuss why in more detail shortly).</li>
<li>Using <code>click()</code> instead of the newer <code>on()</code> API.</li>
<li>Referencing the number <code>10000</code> more than once. What if the client decides this number should be <code>5000</code>? We’d have to change it in three separate places.</li>
<li>We can easily cache some selectors into variables, such as <code>$(&quot;.controls span&quot;)</code>.</li>
<li>We can look at abstracting some of the duplication into functions. For example, lines 23, 30, 46 and 53 are identical.</li>
</ul>
<h2 id="return-false-the-anti-pattern">return false; the anti-pattern</h2>
<p>Currently both the event handlers end with <code>return false</code>:</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="fu">$</span>(<span class="st">&quot;.left&quot;</span>).<span class="fu">click</span>(<span class="kw">function</span>() {
  <span class="co">// things happen here</span>
  <span class="kw">return</span> <span class="kw">false</span>;
});
<span class="fu">$</span>(<span class="st">&quot;.right&quot;</span>).<span class="fu">click</span>(<span class="kw">function</span>() {
  <span class="co">// things happen here</span>
  <span class="kw">return</span> <span class="kw">false</span>;
});</code></pre>
<p>This topic was first talked about back in 2010 in Doug Neiner’s article <a href="http://fuelyourcoding.com/jquery-events-stop-misusing-return-false/">“Stop (mis)using Return False</a> and is still very much relevant today.</p>
<p>jQuery event handlers take one argument, the <em>event object</em>. This object contains information about the event that triggered the event handler to fire. This object not only contains properties, such as the co-ordinates of the mouse pointer when the event took place, but also methods, including <code>preventDefault()</code> and <code>stopPropagation()</code>.</p>
<p><em>Normally</em> when a developer writes <code>return false</code>, what they actually want is to pass the event object in and call <code>event.preventDefault()</code>, like so:</p>
<pre><code>$(&quot;.right&quot;).click(function(event) {
  // things happen here
  event.preventDefault();
});</code></pre>
<p>As I’m sure you’re aware, <code>preventDefault()</code> prevents the default action being taken. <code>return false</code> has the same effect, but it does something else too.</p>
<p>Let’s just head out on a quick tangent to fully discuss propagation. Take a look at the code sample below:</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="fu">$</span>(<span class="kw">function</span>() {
  <span class="fu">$</span>(<span class="st">&quot;div&quot;</span>).<span class="fu">on</span>(<span class="st">&quot;click&quot;</span>, <span class="kw">function</span>() {
    <span class="ot">console</span>.<span class="fu">log</span>(<span class="st">&quot;div got clicked&quot;</span>);
  });

  <span class="fu">$</span>(<span class="st">&quot;div p&quot;</span>).<span class="fu">on</span>(<span class="st">&quot;click&quot;</span>, <span class="kw">function</span>(e) {
    <span class="ot">console</span>.<span class="fu">log</span>(<span class="st">&quot;p got clicked&quot;</span>);
    <span class="ot">e</span>.<span class="fu">stopPropagation</span>();
  });
});</code></pre>
<p>If you were to load that up in a browser and click on the <code>p</code> element within the <code>div</code> element, what would you see in the console? You would only see the second log statement, “p got clicked”. <code>event.stopPropagation()</code> <em>stops the event from bubbling up the DOM tree</em>. There are occasions when this is useful but the majority of the time, you don’t want this. What you might not realise though, is that <strong>return false; has the same effect</strong>. <code>return false</code> has the same effect as calling <code>preventDefault()</code> and <code>stopPropagation()</code>. This can lead to nasty side effects or bugs later which can be incredibly difficult and frustrating to deal with - trust me, I’ve been there.</p>
<p>So although it might take longer, it’s much better to be a bit more verbose here. If you only want the default action to be prevented, call <code>preventDefault()</code>. If you want propagation to be prevented, call <code>stopPropagation()</code>. If you want them both, <strong>don’t type</strong> <code>return false;</code>. Be explicit and type them both out:</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="ot">event</span>.<span class="fu">stopPropagation</span>();
<span class="ot">event</span>.<span class="fu">preventDefault</span>();</code></pre>
<p>The question on where it makes sense to place calls to <code>preventDefault()</code> and <code>stopPropagation()</code> is largely down to you and your preference, but I like to put them at the top as the very first thing that happens in the method. That way it’s easily spotted if you or another developer is reading through the code to see what it does.</p>
<p>So for our first quick win, we can swap out <code>return false</code> with calls to <code>event.preventDefault()</code>. I’ve also put <code>event.preventDefault()</code> at the top, above the rest of the event handler code (which I’ve left out here just to save room).</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="fu">$</span>(<span class="st">&quot;.left&quot;</span>).<span class="fu">click</span>(<span class="kw">function</span>(event) {
  <span class="ot">event</span>.<span class="fu">preventDefault</span>();
  <span class="co">// things happen here</span>
});
<span class="fu">$</span>(<span class="st">&quot;.right&quot;</span>).<span class="fu">click</span>(<span class="kw">function</span>(event) {
  <span class="ot">event</span>.<span class="fu">preventDefault</span>();
  <span class="co">// things happen here</span>
});</code></pre>
<h2 id="on-and-off">on() and off()</h2>
<p>In jQuery 1.7 there was a new API introduced for binding and unbinding event handlers in the form of <code>on()</code> and <code>off()</code> to supersede the old API which was (and still is) a myriad of methods like <code>click()</code>, <code>hover()</code>, <code>mouseout()</code> along with <code>live()</code>, <code>bind()</code> and so on. This point may be a bit contentious, but I think that <code>on()</code> and <code>off()</code> are absolutely vast improvements and the fact that the entire event binding API was able to be reduced to two methods is brilliant. Of course, the old methods are not going anywhere (imagine how much code would break!) but as a rule I now will never use <code>click()</code> or similar, and will always use <code>on(&quot;click&quot;, function() {})</code>. This isn’t going to bring you huge speed improvements or even gain any readability, but personally I do think it reads slightly nicer.</p>
<p>This one’s easy. Just swap out the calls to <code>click</code> with <code>on</code>:</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="fu">$</span>(<span class="st">&quot;.left&quot;</span>).<span class="fu">on</span>(<span class="st">&quot;click&quot;</span>, <span class="kw">function</span>(event) {
  <span class="ot">event</span>.<span class="fu">preventDefault</span>();
  <span class="co">// things happen here</span>
});
<span class="fu">$</span>(<span class="st">&quot;.right&quot;</span>).<span class="fu">on</span>(<span class="st">&quot;click&quot;</span>, <span class="kw">function</span>(event) {
  <span class="ot">event</span>.<span class="fu">preventDefault</span>();
  <span class="co">// things happen here</span>
});</code></pre>
<h2 id="repeated-numbers">Repeated Numbers</h2>
<p>Our code has some numbers that crop up time and time again. The first is <code>300</code>, which I’d refer to as a “Magic Number” and we’ll tackle separately. The second is <code>10000</code>. This isn’t so much a magic number in my opinion as it’s not connected with the page as much. <code>300</code> refers to the width of an image, but it’s not immediately apparent looking at the code that that is the case. We should treat it differently, and we will. <code>10000</code> has no connections, it’s just simply the time we decided should be between each automatic progression of our carousel.</p>
<p>If I were in another language that has <em>constants</em>, I’d define this value as a constant at the top of the file. For example, if this was the language Ruby I could simply do:</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="dt">CAROUSEL_TRANSITION_TIME</span> = <span class="dv">10000</span></code></pre>
<p>That constant would then be set to 10,000 and nothing could possibly change it later on.</p>
<p>Although JavaScript doesn’t have constants, a convention has formed that any variable in capital letters should be treated as such. So I’d actually type exactly what I typed above in the Ruby example, and place it towards the top of the JavaScript file:</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="fu">$</span>(<span class="kw">function</span>() {
  CAROUSEL_TRANSITION_TIME = <span class="dv">10000</span>;

  <span class="kw">if</span>(<span class="ot">location</span>.<span class="fu">hash</span> &amp;&amp; <span class="ot">location</span>.<span class="ot">hash</span>.<span class="fu">indexOf</span>(<span class="st">&quot;image&quot;</span>) &gt; -<span class="dv">1</span>) {
    <span class="co">// more code</span></code></pre>
<p>And then I’d replace all occurrences of <code>10000</code> in the code with <code>CAROUSEL_TRANSITION_TIME</code>:</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> timeout = <span class="fu">setTimeout</span>(<span class="kw">function</span>() {
  <span class="fu">$</span>(<span class="st">&quot;.left&quot;</span>).<span class="fu">trigger</span>(<span class="st">&quot;click&quot;</span>);
}, CAROUSEL_TRANSITION_TIME);</code></pre>
<p>And similarly in the other two places it occurs.</p>
<p>By doing this we’ve definitely made this code more maintainable. Say the client turns up and wants the value changed. Now we’ve just one value to change, instead of three. Try to get into the habit of defining things as constants early. You can always remove the constant if you end up using it once, but it’s a good practice to get into if you find yourself referring to the same value over and over again.</p>
<p>I&gt; Remember that constants should never be altered - in languages with actual support for constants, you are unable to edit them, you should treat your makeshift JavaScript constants equally.</p>
<h2 id="caching-selectors">Caching selectors</h2>
<p>This is something that everybody <em>should</em> do but people don’t always do it (I know I’m guilty). jQuery makes it so easy to quickly query the DOM for something that it’s easy to just keep doing it and pay no attention to if you’ve done that previously or not. The common argument for this is largely performance. Whilst there is an obvious performance increase if you can avoid doing something multiple times, I would argue that today the main reason behind this should be the maintainability of your code. In the previous section we just swapped out occurrences of <code>10000</code> with a constant which took us from 3 changes down to 1 if that number should change.</p>
<p>Take a look at the carousel code and selectors that come up time and time again. There’s not too many unique selectors but they all occur multiple times:</p>
<ul>
<li><code>ul</code> (5 times)</li>
<li><code>.controls span</code> (5 times)</li>
<li><code>.left</code> (4 times)</li>
<li><code>.right</code> (once)</li>
</ul>
<p>The fix for this is simple, and I’m sure you already know what’s coming up. <strong>Cache those selectors!</strong>.</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> ul = <span class="fu">$</span>(<span class="st">&quot;ul&quot;</span>);
<span class="kw">var</span> controlText = <span class="fu">$</span>(<span class="st">&quot;.controls span&quot;</span>);
<span class="kw">var</span> leftLink = <span class="fu">$</span>(<span class="st">&quot;.left&quot;</span>);
<span class="kw">var</span> rightLink = <span class="fu">$</span>(<span class="st">&quot;.right&quot;</span>);</code></pre>
<p>Now go through and replace all occurrences of each selector with the relevant variable. What we’ve achieved here is a much easier job, should any of these selectors change. If you take anything away from this section, make it be this:</p>
<p><strong>Anything that could change should only be referenced <em>once</em> in your code</strong>.</p>
<p>Make changes and alterations as frictionless as possible and everyone’s happy.</p>
<h2 id="functions">functions</h2>
<p>We’re going to look more in depth at functions in a later chapter, where we’ll discuss their usage and some technical details in depth. This section can serve as a precursor to that.</p>
<p>A lot of people I talk to seem wary of using functions, like they come with some huge cost that people can’t afford. In other communities like the Ruby one (which I’ll reference purely because it’s the one I’m most familiar with) it’s very common to see posts heavily advocating using methods in Ruby. Ben Orenstein talks heavily about how he’s incredibly aggressive at abstracting code into new methods and having methods of extremely short length. I agree with Ben’s approach entirely we can certainly take some of what he says and apply it to our code.</p>
<p>As I said, we’ll go much more into this later, but for now let’s look at one quick example. This very line crops up four times:</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="ot">controlText</span>.<span class="fu">text</span>(<span class="st">&quot;Current: &quot;</span> + (currentImage + <span class="dv">1</span>));</code></pre>
<p>By abstracting this line into its own function we can gain a large amount:</p>
<ol type="1">
<li><em>Maintainability</em>. This code contains something that very much could change - the text that we put into the page to show the user what number they are on. Right now, that change would have to be made in four places.</li>
<li><em>Readability</em>. If you extract code into a function and name that function well, it’s then less code for a developer to have to read to understand the functionality. If, instead of the line above, we just had a call to <code>updateControlText()</code>, I can understand what that means <em>instantly</em>, and move on. I can understand what that means a lot quicker than I can understand what <code>controlText.text(&quot;Current: &quot; + (currentImage + 1));</code> means.</li>
<li>Plus, it’s a first step towards properly structuring our code, something we’ll also look into in more detail later.</li>
</ol>
<p>Let’s make the change. At the top of the code, just below all your selector variables, add the function:</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> updateControlText = <span class="kw">function</span>() {
  <span class="ot">controlText</span>.<span class="fu">text</span>(<span class="st">&quot;Current: &quot;</span> + (currentImage + <span class="dv">1</span>));
};</code></pre>
<p>And then we can update the code to make use of it:</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="ot">ul</span>.<span class="fu">animate</span>({
  <span class="st">&quot;margin-left&quot;</span>: number * -<span class="dv">300</span>
}, <span class="kw">function</span>() {
  currentImage = number;
  <span class="fu">updateControlText</span>();
});</code></pre>
<p>(And in the other three locations too).</p>
<h2 id="summary">Summary</h2>
<p>With that change we’ve made <strong>five</strong> really quick and simple changes that have already improved our code hugely, with very little time spent making them. As you get used to spotting these problems and fixing them, you’ll find it becomes almost second nature to make them all the time, without thinking.</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="fu">$</span>(<span class="kw">function</span>() {
  <span class="kw">var</span> CAROUSEL_TRANSITION_TIME = <span class="dv">10000</span>;
  <span class="kw">var</span> ul = <span class="fu">$</span>(<span class="st">&quot;ul&quot;</span>);
  <span class="kw">var</span> controlText = <span class="fu">$</span>(<span class="st">&quot;.controls span&quot;</span>);
  <span class="kw">var</span> leftLink = <span class="fu">$</span>(<span class="st">&quot;.left&quot;</span>);
  <span class="kw">var</span> rightLink = <span class="fu">$</span>(<span class="st">&quot;.right&quot;</span>);

  <span class="kw">var</span> updateControlText = <span class="kw">function</span>() {
    <span class="ot">controlText</span>.<span class="fu">text</span>(<span class="st">&quot;Current: &quot;</span> + (currentImage + <span class="dv">1</span>));
  };

  <span class="kw">if</span>(<span class="ot">location</span>.<span class="fu">hash</span> &amp;&amp; <span class="ot">location</span>.<span class="ot">hash</span>.<span class="fu">indexOf</span>(<span class="st">&quot;image&quot;</span>) &gt; -<span class="dv">1</span>) {
    <span class="kw">var</span> number = <span class="fu">parseInt</span>(<span class="ot">location</span>.<span class="ot">hash</span>.<span class="fu">charAt</span>(<span class="ot">location</span>.<span class="ot">hash</span>.<span class="fu">length</span> -<span class="dv">1</span>));
    <span class="ot">ul</span>.<span class="fu">animate</span>({
      <span class="st">&quot;margin-left&quot;</span>: number * -<span class="dv">300</span>
    }, <span class="kw">function</span>() {
      currentImage = number;
      <span class="fu">updateControlText</span>();
    });
  }
  <span class="kw">var</span> timeout = <span class="fu">setTimeout</span>(<span class="kw">function</span>() {
    <span class="ot">leftLink</span>.<span class="fu">trigger</span>(<span class="st">&quot;click&quot;</span>);
  }, CAROUSEL_TRANSITION_TIME);

  <span class="kw">var</span> currentImage = <span class="dv">0</span>;
  <span class="ot">leftLink</span>.<span class="fu">on</span>(<span class="st">&quot;click&quot;</span>, <span class="kw">function</span>(event) {
    <span class="ot">event</span>.<span class="fu">preventDefault</span>();
    <span class="fu">clearTimeout</span>(timeout);
    <span class="kw">if</span>(currentImage == <span class="fu">$</span>(<span class="st">&quot;li&quot;</span>).<span class="fu">length</span> - <span class="dv">1</span>) {
      <span class="ot">ul</span>.<span class="fu">animate</span>({
        <span class="st">&quot;margin-left&quot;</span>: <span class="dv">0</span>
      }, <span class="kw">function</span>() {
        currentImage = <span class="dv">0</span>;
        <span class="fu">updateControlText</span>();
      });
    } <span class="kw">else</span> {
      <span class="ot">ul</span>.<span class="fu">animate</span>({
        <span class="st">&quot;margin-left&quot;</span>: <span class="st">&quot;-=300px&quot;</span>
      }, <span class="kw">function</span>() {
        currentImage+=<span class="dv">1</span>;
        <span class="fu">updateControlText</span>();
      });
    }
    timeout = <span class="fu">setTimeout</span>(<span class="kw">function</span>() {
      <span class="ot">leftLink</span>.<span class="fu">trigger</span>(<span class="st">&quot;click&quot;</span>);
    }, CAROUSEL_TRANSITION_TIME);
  });

  <span class="ot">rightLink</span>.<span class="fu">on</span>(<span class="st">&quot;click&quot;</span>, <span class="kw">function</span>(event) {
    <span class="ot">event</span>.<span class="fu">preventDefault</span>();
    <span class="fu">clearTimeout</span>(timeout);
    <span class="kw">if</span>(currentImage == <span class="dv">0</span>) {
      <span class="ot">ul</span>.<span class="fu">animate</span>({
        <span class="st">&quot;margin-left&quot;</span>: (<span class="fu">$</span>(<span class="st">&quot;li&quot;</span>).<span class="fu">length</span> - <span class="dv">1</span>) * -<span class="dv">300</span>
      }, <span class="kw">function</span>() {
        currentImage = <span class="fu">$</span>(<span class="st">&quot;li&quot;</span>).<span class="fu">length</span> - <span class="dv">1</span>;
        <span class="fu">updateControlText</span>();
      });
    } <span class="kw">else</span> {
      <span class="ot">ul</span>.<span class="fu">animate</span>({
        <span class="st">&quot;margin-left&quot;</span>: <span class="st">&quot;+=300px&quot;</span>
      }, <span class="kw">function</span>() {
        currentImage-=<span class="dv">1</span>;
        <span class="fu">updateControlText</span>();
      });
    }
    timeout = <span class="fu">setTimeout</span>(<span class="kw">function</span>() {
      <span class="ot">leftLink</span>.<span class="fu">trigger</span>(<span class="st">&quot;click&quot;</span>);
    }, CAROUSEL_TRANSITION_TIME);
  });
});</code></pre>
<p>In the next chapter we will look more in depth at a smaller block of code I wrote recently that’s absolutely terrible, and see if we can’t improve it.</p>
<h1 id="tale-3-async-abominations">Tale 3: Async Abominations</h1>
<p>The code for this example comes directly from a project I was working on recently. I was building a NodeJS powered API, and as part of that, needed a way of validating parameters that were passed as query strings in the API request. Every single request needs to be passed a <code>token</code> parameter, which is matched to the token of a user in the database, and some requests take a <code>userId</code> parameter, along with a token. In the case that both the token and userId are passed in, we validate that the token is the token for that specific user. In the case where we just take in a token, we validate that the token is valid, and exists in our database.</p>
<p>The API has many routes, so I wanted to abstract this into a function, which I called <code>validateParamsExist</code>. It is used like so:</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="fu">validateParamsExist</span>([<span class="st">&#39;userId&#39;</span>, <span class="st">&#39;token&#39;</span>, <span class="st">&#39;foo&#39;</span>], req, res, <span class="kw">function</span>(requestIsValid) {
  <span class="kw">if</span>(requestIsValid) {
    <span class="co">// all parameters were passed</span>
  } <span class="kw">else</span> {
    <span class="co">// something went wrong</span>
  }
});</code></pre>
<p>The function takes four arguments: - an array of parameters to ensure exist - the ExpressJS request object (don’t worry if you don’t know what it is, all you need to know is that it stores all the information about the request) - the ExpressJS response object (this is what we use to return data from the API) - a callback function, which is called once the validation is complete with a single argument, which is <code>true</code> if the validations passed, and <code>false</code> if it did not.</p>
<p>It’s also important to note that the ExpressJS request object (in the code, I refer to it as <code>req</code>), stores the parameters that we got with the URL in an object, which is stored in <code>req.query</code>. So if I made a request that looked like this: <code>http://somesite.com/foo?name=jack&amp;id=123</code>, <code>req.query</code> would look like so:</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="ot">req</span>.<span class="fu">query</span> = {
  <span class="dt">name</span>: <span class="st">&#39;jack&#39;</span>,
  <span class="dt">id</span>: <span class="st">&#39;123&#39;</span>
};</code></pre>
<p>The challenge here and why this refactor offers a different challenge to the others is because it’s asynchronous. It performs tasks asynchronously and hence it’s a bit more of an effort to pull pieces out. The basic idea for the implementation of this function is as follows:</p>
<ol type="1">
<li>Loop over every parameter the user is expecting, and make sure it exists</li>
<li>If the parameter is <code>token</code>, do some extra validation (as explained above). The exact extra validation to be done depends on if we also have a <code>userId</code> parameter or not.</li>
</ol>
<h2 id="the-code">The code</h2>
<p>Rather than show you the starting code, which is badly written and tough to understand, I’m going to show you the finished code first. This is what my refactoring lead me to:</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> matchTokenToUser = <span class="kw">function</span>(token, userId, errors, done) {
  <span class="co">// method for making sure a token matches a user</span>
}

<span class="kw">var</span> ensureTokenExists = <span class="kw">function</span>(token, errors, done) {
  <span class="co">// method for ensuring a token exists</span>
};

<span class="kw">var</span> noParamsPassed = <span class="kw">function</span>(req, res) {
  <span class="kw">if</span>(<span class="ot">req</span>.<span class="fu">query</span>) {
    <span class="kw">return</span> <span class="kw">false</span>;
  } <span class="kw">else</span> {
    <span class="ot">res</span>.<span class="fu">json</span>({ <span class="dt">errors</span>: [<span class="st">&#39;no parameters supplied&#39;</span>] });
    <span class="kw">return</span> <span class="kw">true</span>;
  }
};

<span class="kw">var</span> checkTokenAndIds = <span class="kw">function</span>(req, errors, cb) {
  <span class="kw">var</span> token = <span class="ot">req</span>.<span class="ot">query</span>.<span class="fu">token</span>;
  <span class="kw">var</span> userId = <span class="ot">req</span>.<span class="ot">query</span>.<span class="fu">userId</span>;
  <span class="kw">if</span>(token) {
    <span class="kw">if</span>(userId) {
      <span class="fu">matchTokenToUser</span>(token, userId, errors, cb);
    } <span class="kw">else</span> {
      <span class="fu">ensureTokenExists</span>(token, errors, cb);
    }
  } <span class="kw">else</span> {
    <span class="fu">cb</span>();
  }
};

<span class="kw">var</span> validateParamsExist = <span class="kw">function</span>(params, req, res, cb) {
  <span class="kw">if</span>(<span class="fu">noParamsPassed</span>(req, res)) <span class="kw">return</span> <span class="fu">cb</span>(<span class="kw">false</span>);

  <span class="kw">var</span> errors = [];
  <span class="ot">params</span>.<span class="fu">forEach</span>(<span class="kw">function</span>(p) {
    <span class="kw">if</span>(!<span class="ot">req</span>.<span class="fu">query</span>[p]) <span class="ot">errors</span>.<span class="fu">push</span>(<span class="st">&#39;parameter &#39;</span> + p + <span class="st">&#39; is required&#39;</span>);
  });

  <span class="fu">checkTokenAndIds</span>(req, errors, <span class="kw">function</span>() {
    <span class="kw">if</span>(<span class="ot">errors</span>.<span class="fu">length</span> &gt; <span class="dv">0</span>) {
      <span class="ot">res</span>.<span class="fu">json</span>({ <span class="dt">errors</span>: errors });
      <span class="kw">return</span> <span class="fu">cb</span>(<span class="kw">false</span>);
    } <span class="kw">else</span> {
      <span class="kw">return</span> <span class="fu">cb</span>(<span class="kw">true</span>);
    }
  });
};</code></pre>
<p>Have a read through the code, starting with the <code>validateParamsExist</code> method, and see if it makes sense. I have left some implementation details of functions out, because it plays no part in the refactoring (the method we’ll start with shortly also has <code>ensureTokenExists</code> and <code>matchTokenToUser</code>, too).</p>
<p>Stepping through the <code>validateParamsExist</code> method, here’s what it does:</p>
<ol type="1">
<li>If no parameters at all were passed, call the callback and pass in <code>false</code>, because the validation failed.</li>
<li>Go through each parameter we are expecting, and make sure that it actually exists. If it doesn’t, store an error in the <code>errors</code> array.</li>
<li>Check to see if the token and id parameters were passed, and ensure that they are as expected.</li>
<li>Once the checking of tokens and id are complete, check to see if the <code>errors</code> array has any items. If it does, use <code>res.json</code> to return those errors from the API, and call the callback with <code>false</code>, because the validation failed.</li>
<li>Else, if we have no errors, call the callback with <code>true</code>, because the validation must have passed.</li>
</ol>
<h2 id="back-to-the-beginning">Back to the beginning</h2>
<p>I showed you the finished version first because it’s readable and easy to digest what is going on, everything the first implementation isn’t. What we’ll do now is look at the pre-refactoring code and then step through the refactorings I made to get to the above code. Brace yourself, because here is the previous version:</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> matchTokenToUser = <span class="kw">function</span>(token, userId, errors, done) {
  <span class="co">// implementation irrelevant</span>
}

<span class="kw">var</span> ensureTokenExists = <span class="kw">function</span>(token, errors, done) {
  <span class="co">// implementation irrelevant</span>
};

<span class="kw">var</span> validateParamsExist = <span class="kw">function</span>(params, req, res, cb) {
  <span class="kw">if</span>(!<span class="ot">req</span>.<span class="fu">query</span>) {
    <span class="ot">res</span>.<span class="fu">json</span>({ <span class="dt">errors</span>: [<span class="st">&#39;no parameters supplied&#39;</span>] });
    <span class="kw">return</span> <span class="fu">cb</span>(<span class="kw">false</span>);
  } <span class="kw">else</span> {
    <span class="kw">var</span> errors = [];
    <span class="ot">async</span>.<span class="fu">each</span>(params, <span class="kw">function</span>(p, callback) {
      <span class="kw">if</span>(!<span class="ot">req</span>.<span class="fu">query</span>[p]) {
        <span class="ot">errors</span>.<span class="fu">push</span>(<span class="st">&#39;parameter &#39;</span> + p + <span class="st">&#39; is required&#39;</span>);
        <span class="fu">callback</span>();
      } <span class="kw">else</span> {
        <span class="kw">if</span>(p === <span class="st">&#39;token&#39;</span> &amp;&amp; <span class="ot">req</span>.<span class="ot">query</span>.<span class="fu">token</span>) {
          <span class="kw">if</span>(<span class="ot">params</span>.<span class="fu">indexOf</span>(<span class="st">&#39;userId&#39;</span>) &gt; -<span class="dv">1</span> &amp;&amp; <span class="ot">req</span>.<span class="ot">query</span>.<span class="fu">userId</span>) {
            <span class="fu">matchTokenToUser</span>(<span class="ot">req</span>.<span class="ot">query</span>.<span class="fu">token</span>, <span class="ot">req</span>.<span class="ot">query</span>.<span class="fu">userId</span>, errors, callback);
          } <span class="kw">else</span> {
            <span class="fu">ensureTokenExists</span>(<span class="ot">req</span>.<span class="ot">query</span>.<span class="fu">token</span>, errors, callback);
          }
        } <span class="kw">else</span> {
          <span class="fu">callback</span>();
        }
      }
    }, <span class="kw">function</span>(err) {
      <span class="kw">if</span>(<span class="ot">errors</span>.<span class="fu">length</span> &gt; <span class="dv">0</span>) {
        <span class="ot">res</span>.<span class="fu">json</span>({ <span class="dt">errors</span>: errors });
        <span class="kw">return</span> <span class="fu">cb</span>(<span class="kw">false</span>);
      } <span class="kw">else</span> {
        <span class="kw">return</span> <span class="fu">cb</span>(<span class="kw">true</span>);
      }
    });
  };
}</code></pre>
<p>Take a moment to read through that and see what’s going on. The good news is it can’t get any worse than this - things are only going to get better from here!</p>
<h2 id="abstracting-functions">Abstracting functions</h2>
<p>Before I even begin to look at the main block of code, that starts with the call to <code>async.each</code>, I like to immediately abstract out small blocks into functions. This is the kind of change that I might undo at a later point, but I find it really helps as a starting point to just split one large method up into a bunch of smaller functions if possible. The first bit we can do that for is the first part of our function, the <code>if(!req.query)...</code> part:</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> noParamsPassed = <span class="kw">function</span>(req, res) {
  <span class="kw">if</span>(<span class="ot">req</span>.<span class="fu">query</span>) {
    <span class="kw">return</span> <span class="kw">false</span>;
  } <span class="kw">else</span> {
    <span class="ot">res</span>.<span class="fu">json</span>({ <span class="dt">errors</span>: [<span class="st">&#39;no parameters supplied&#39;</span>] });
    <span class="kw">return</span> <span class="kw">true</span>;
  }
};

<span class="kw">var</span> validateParamsExist = <span class="kw">function</span>(params, req, res, cb) {
  <span class="kw">if</span>(<span class="fu">noParamsPassed</span>(req, res)) <span class="kw">return</span> <span class="fu">cb</span>(<span class="kw">false</span>);
  <span class="kw">var</span> errors = [];
  <span class="ot">async</span>.<span class="fu">each</span>(params, <span class="kw">function</span>(p, callback) {
    <span class="kw">if</span>(!<span class="ot">req</span>.<span class="fu">query</span>[p]) {
      <span class="ot">errors</span>.<span class="fu">push</span>(<span class="st">&#39;parameter &#39;</span> + p + <span class="st">&#39; is required&#39;</span>);
      <span class="fu">callback</span>();
    } <span class="kw">else</span> {
      <span class="kw">if</span>(p === <span class="st">&#39;token&#39;</span> &amp;&amp; <span class="ot">req</span>.<span class="ot">query</span>.<span class="fu">token</span>) {
        <span class="kw">if</span>(<span class="ot">params</span>.<span class="fu">indexOf</span>(<span class="st">&#39;userId&#39;</span>) &gt; -<span class="dv">1</span> &amp;&amp; <span class="ot">req</span>.<span class="ot">query</span>.<span class="fu">userId</span>) {
          <span class="fu">matchTokenToUser</span>(<span class="ot">req</span>.<span class="ot">query</span>.<span class="fu">token</span>, <span class="ot">req</span>.<span class="ot">query</span>.<span class="fu">userId</span>, errors, callback);
        } <span class="kw">else</span> {
          <span class="fu">ensureTokenExists</span>(<span class="ot">req</span>.<span class="ot">query</span>.<span class="fu">token</span>, errors, callback);
        }
      } <span class="kw">else</span> {
        <span class="fu">callback</span>();
      }
    }
  }, <span class="kw">function</span>(err) {
    <span class="kw">if</span>(<span class="ot">errors</span>.<span class="fu">length</span> &gt; <span class="dv">0</span>) {
      <span class="ot">res</span>.<span class="fu">json</span>({ <span class="dt">errors</span>: errors });
      <span class="kw">return</span> <span class="fu">cb</span>(<span class="kw">false</span>);
    } <span class="kw">else</span> {
      <span class="kw">return</span> <span class="fu">cb</span>(<span class="kw">true</span>);
    }
  });
}</code></pre>
<p>Doing this also means we can get rid of the <code>if(!req.query)</code> conditional that wrapped most of the body of the <code>validateParamsExist</code> method. I find exiting early is preferable to wrapping functions in large conditionals. These are what we call <strong>guard clauses</strong> - a conditional which checks something that is required for the function to be able to run. If it’s not there, it’s best to figure it out right away and ditch out early. Some argue that functions having multiple returns makes them unclear, but I’d much rather that then have large conditionals wrapping functions. Those are much more unclear, in my opinion.</p>
<p>The next abstraction is to pull out the code that checks for the existence of <code>token</code> and/or <code>userId</code> parameters.</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> checkTokenAndIds = <span class="kw">function</span>(p, req, errors, callback) {
  <span class="kw">if</span>(p === <span class="st">&#39;token&#39;</span> &amp;&amp; <span class="ot">req</span>.<span class="ot">query</span>.<span class="fu">token</span>) {
    <span class="kw">if</span>(<span class="ot">params</span>.<span class="fu">indexOf</span>(<span class="st">&#39;userId&#39;</span>) &gt; -<span class="dv">1</span> &amp;&amp; <span class="ot">req</span>.<span class="ot">query</span>.<span class="fu">userId</span>) {
      <span class="fu">matchTokenToUser</span>(<span class="ot">req</span>.<span class="ot">query</span>.<span class="fu">token</span>, <span class="ot">req</span>.<span class="ot">query</span>.<span class="fu">userId</span>, errors, callback);
    } <span class="kw">else</span> {
      <span class="fu">ensureTokenExists</span>(<span class="ot">req</span>.<span class="ot">query</span>.<span class="fu">token</span>, errors, callback);
    }
  } <span class="kw">else</span> {
    <span class="fu">callback</span>();
  }
};

<span class="co">// left out noParamsPassed fn so this code takes up less room</span>

<span class="kw">var</span> validateParamsExist = <span class="kw">function</span>(params, req, res, cb) {
  <span class="kw">if</span>(<span class="fu">noParamsPassed</span>(req, res)) <span class="kw">return</span> <span class="fu">cb</span>(<span class="kw">false</span>);
  <span class="kw">var</span> errors = [];
  <span class="ot">async</span>.<span class="fu">each</span>(params, <span class="kw">function</span>(p, callback) {
    <span class="kw">if</span>(!<span class="ot">req</span>.<span class="fu">query</span>[p]) {
      <span class="ot">errors</span>.<span class="fu">push</span>(<span class="st">&#39;parameter &#39;</span> + p + <span class="st">&#39; is required&#39;</span>);
      <span class="fu">callback</span>();
    } <span class="kw">else</span> {
      <span class="fu">checkTokenAndIds</span>(p, req, errors, callback);
    }
  }, <span class="kw">function</span>(err) {
    <span class="kw">if</span>(<span class="ot">errors</span>.<span class="fu">length</span> &gt; <span class="dv">0</span>) {
      <span class="ot">res</span>.<span class="fu">json</span>({ <span class="dt">errors</span>: errors });
      <span class="kw">return</span> <span class="fu">cb</span>(<span class="kw">false</span>);
    } <span class="kw">else</span> {
      <span class="kw">return</span> <span class="fu">cb</span>(<span class="kw">true</span>);
    }
  });
}</code></pre>
<p>The <code>checkTokenAndIds</code> is far from a perfect function, and later we will refactor it. However, once we get to the stage where we’ve pulled code out into functions, we can now digest <code>validateParamsExist</code> much easier.</p>
<p>When I started to look at this code, the first thing I spotted was how all of this code is wrapped within an <code>async.each</code> call. This is part of the fantastic <a href="https://github.com/caolan/async">async</a> library. <code>async.each</code> offers a way to loop over an array and perform some asynchronous code for each, and then run some other code once all items have been looped over. The usage of it above though is far from sensible:</p>
<ol type="1">
<li>The first part of the <code>async.each</code>, which checks for the existence of a parameter, is not asynchronous.</li>
<li>The second part, which checks the validity of any token or userId params, only needs to run once, not every time.</li>
</ol>
<p>It turns out that the only part of this code which does need to run in a loop is the parameter existence check, and that’s not asynchronous. We can run the code that checks for tokens and ids only once, so why is it in a loop?! (As an aside, when I wrote this code the first time I didn’t spot this. Looking back, I’m not sure what I was thinking!).</p>
<p>Making the first step of changes leaves us with code that looks like this:</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> validateParamsExist = <span class="kw">function</span>(params, req, res, cb) {
  <span class="kw">if</span>(<span class="fu">noParamsPassed</span>(req, res)) <span class="kw">return</span> <span class="fu">cb</span>(<span class="kw">false</span>);
  <span class="kw">var</span> errors = [];
  <span class="ot">params</span>.<span class="fu">forEach</span>(<span class="kw">function</span>(p) {
    <span class="kw">if</span>(!<span class="ot">req</span>.<span class="fu">query</span>[p]) <span class="ot">errors</span>.<span class="fu">push</span>(<span class="st">&#39;parameter &#39;</span> + p + <span class="st">&#39; is required&#39;</span>);
  });

  <span class="co">// need to checkTokenAndIds next</span>
  <span class="co">//...</span>
}</code></pre>
<p>The signature of the <code>checkTokenAndIds</code> function needs to change somewhat now. Previously we passed in the current parameter, but now we just need to give it all the parameters, our array of errors, and a function to call when it’s finished its checks. Here’s the final version of the <code>checkTokenAndIds</code> method I came up with:</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> checkTokenAndIds = <span class="kw">function</span>(req, errors, cb) {
  <span class="kw">var</span> token = <span class="ot">req</span>.<span class="ot">query</span>.<span class="fu">token</span>;
  <span class="kw">var</span> userId = <span class="ot">req</span>.<span class="ot">query</span>.<span class="fu">userId</span>;
  <span class="kw">if</span>(token) {
    <span class="kw">if</span>(userId) {
      <span class="fu">matchTokenToUser</span>(token, userId, errors, cb);
    } <span class="kw">else</span> {
      <span class="fu">ensureTokenExists</span>(token, errors, cb);
    }
  } <span class="kw">else</span> {
    <span class="fu">cb</span>();
  }
};</code></pre>
<p>Don’t worry about the implementation of <code>matchTokenToUser</code> or <code>ensureTokenExists</code> - they are both simple methods that just run some database queries, but they have no effect on this chapter. Notice how this method tells a story very effectively, and it’s easy to go down it line by line and see what’s happening, and follow the story. We can now go and add this method back into <code>validateParamsExist</code>:</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> validateParamsExist = <span class="kw">function</span>(params, req, res, cb) {
  <span class="kw">if</span>(<span class="fu">noParamsPassed</span>(req, res)) <span class="kw">return</span> <span class="fu">cb</span>(<span class="kw">false</span>);
  <span class="kw">var</span> errors = [];
  <span class="ot">params</span>.<span class="fu">forEach</span>(<span class="kw">function</span>(p) {
    <span class="kw">if</span>(!<span class="ot">req</span>.<span class="fu">query</span>[p]) <span class="ot">errors</span>.<span class="fu">push</span>(<span class="st">&#39;parameter &#39;</span> + p + <span class="st">&#39; is required&#39;</span>);
  });

  <span class="fu">checkTokenAndIds</span>(req, errors, <span class="kw">function</span>() {
    <span class="kw">if</span>(<span class="ot">errors</span>.<span class="fu">length</span> &gt; <span class="dv">0</span>) {
      <span class="ot">res</span>.<span class="fu">json</span>({ <span class="dt">errors</span>: errors });
      <span class="kw">return</span> <span class="fu">cb</span>(<span class="kw">false</span>);
    } <span class="kw">else</span> {
      <span class="kw">return</span> <span class="fu">cb</span>(<span class="kw">true</span>);
    }
  });
}</code></pre>
<p>And we’re done! This example was slightly different to previous examples - whilst the previous two chapters had code that was perfectly OK but had potential for some improvement, this code was just plain misleading, poorly constructed and badly written. Imagine if you had to make a change to the validation logic, and you had this block of code as your starting point. Do you think you could do it easily? I’m pretty sure I couldn’t.</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> validateParamsExist = <span class="kw">function</span>(params, req, res, cb) {
  <span class="kw">if</span>(!<span class="ot">req</span>.<span class="fu">query</span>) {
    <span class="ot">res</span>.<span class="fu">json</span>({ <span class="dt">errors</span>: [<span class="st">&#39;no parameters supplied&#39;</span>] });
    <span class="kw">return</span> <span class="fu">cb</span>(<span class="kw">false</span>);
  } <span class="kw">else</span> {
    <span class="kw">var</span> errors = [];
    <span class="ot">async</span>.<span class="fu">each</span>(params, <span class="kw">function</span>(p, callback) {
      <span class="kw">if</span>(!<span class="ot">req</span>.<span class="fu">query</span>[p]) {
        <span class="ot">errors</span>.<span class="fu">push</span>(<span class="st">&#39;parameter &#39;</span> + p + <span class="st">&#39; is required&#39;</span>);
        <span class="fu">callback</span>();
      } <span class="kw">else</span> {
        <span class="kw">if</span>(p === <span class="st">&#39;token&#39;</span> &amp;&amp; <span class="ot">req</span>.<span class="ot">query</span>.<span class="fu">token</span>) {
          <span class="kw">if</span>(<span class="ot">params</span>.<span class="fu">indexOf</span>(<span class="st">&#39;userId&#39;</span>) &gt; -<span class="dv">1</span> &amp;&amp; <span class="ot">req</span>.<span class="ot">query</span>.<span class="fu">userId</span>) {
            <span class="fu">matchTokenToUser</span>(<span class="ot">req</span>.<span class="ot">query</span>.<span class="fu">token</span>, <span class="ot">req</span>.<span class="ot">query</span>.<span class="fu">userId</span>, errors, callback);
          } <span class="kw">else</span> {
            <span class="fu">ensureTokenExists</span>(<span class="ot">req</span>.<span class="ot">query</span>.<span class="fu">token</span>, errors, callback);
          }
        } <span class="kw">else</span> {
          <span class="fu">callback</span>();
        }
      }
    }, <span class="kw">function</span>(err) {
      <span class="kw">if</span>(<span class="ot">errors</span>.<span class="fu">length</span> &gt; <span class="dv">0</span>) {
        <span class="ot">res</span>.<span class="fu">json</span>({ <span class="dt">errors</span>: errors });
        <span class="kw">return</span> <span class="fu">cb</span>(<span class="kw">false</span>);
      } <span class="kw">else</span> {
        <span class="kw">return</span> <span class="fu">cb</span>(<span class="kw">true</span>);
      }
    });
  };
}</code></pre>
<p>Compare that to the code we ended up with after sitting back, carefully going through the method to see exactly what it does and how it should work. The code is cleaner, its intention is obvious, there’s less nesting and indentation (a very basic, but often useful metric) and it reads nicer.</p>
<p>Any developer who tells you that they have never looked back over some code they’ve previously written and cringed is a liar. You’re never going to get it right first time, and the purpose of this book isn’t to try to make you to produce great code first time, but to spot where improvements can be made. Andy Appleton, a developer I’ve had the pleasure with working with, put this best when we were talking about this kind of thing one day. He said:</p>
<blockquote>
<p>Defer concrete decisions as late as possible - you’ll never again know less about the problem than you do right now and the correct abstraction will become clearer over time.</p>
</blockquote>
<p>As time goes on and you become more settled within the context of what you’re working on, refactorings, abstractions of classes and small tweaks should become easier to spot over time.</p>
<h1 id="tale-4-parsing-problems">Tale 4: Parsing Problems</h1>
<p>In this chapter we’re not going to look in as much detail at implementation specifics as we did in the first, but more on the overall structure of bits of code across a large system. Whilst the structure of individual blocks of code is important, arguably more so is the relationship of these components across a software system, and it’s this that I want to talk about in this chapter.</p>
<h2 id="email-sending"> Email Sending</h2>
<p>As always, we need some code to work with, and this time we’re looking at some code that has to send emails. It takes in a CSV, which contains details of users, including their email address, and uses that data to get a list of emails, which it then takes and sends an email to.</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> EmailSender = {
  <span class="dt">init</span>: <span class="kw">function</span>(csv) {
    <span class="kw">this</span>.<span class="fu">csv</span> = csv;
    <span class="kw">return</span> <span class="kw">this</span>;
  },
  <span class="dt">parseEmailsFromCsv</span>: <span class="kw">function</span>() {
    <span class="co">// implementation not important</span>
    <span class="kw">this</span>.<span class="fu">emails</span> = [...]
  },
  <span class="dt">sendEmail</span>: <span class="kw">function</span>() {
    <span class="co">// sends email, implementation not important</span>
    <span class="kw">this</span>.<span class="ot">emails</span>.<span class="fu">forEach</span>(...);
  }
};</code></pre>
<p>On the surface of it, this object might seem pretty perfect to you. I’ve simplified it down slightly for the purposes of this book, but the details are mostly the same. It has a method to parse the emails out of the CSV, and then a method to take those emails and send an email to them.</p>
<h2 id="single-responsibility-principle">Single Responsibility Principle</h2>
<p>However, this code violates the Single Responsibility Principle (or SRP, as I’ll refer to it from now on). The Single Responsibility Principle states that one object should <strong>do one thing</strong>, and <strong>do it well</strong>. Our email sender right now has two responsibilities:</p>
<ol type="1">
<li>Parse the user emails out of a CSV.</li>
<li>Send an email to a list of email addresses</li>
</ol>
<p>To me, that looks like two distinct responsibilities. Whilst this might not be an issue now, in the future of this large app you could imagine another part of the system wanting to send emails, or needing to parse data out of a CSV. Splitting this code up into two objects will benefit us now, but will probably benefit us more in the long run. This doesn’t mean that tomorrow at work you should aggressively split up a single object into many smaller ones, but spotting instances where an object is doing too much is a good skill to master. Often these type of refactorings are more about saving pain later down the line than immediate reward, but that doesn’t make them any less worthwhile. Long term, once you get used to the concept of SRP, you will find yourself keeping it in mind from the very moment you begin to build a new object.</p>
<h2 id="an-improvement">An improvement</h2>
<p>Just like any other improvement, we’re going to do it in small steps. Firstly, I can create a <code>Parser</code> object, that takes a CSV and can pull details out of it:</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> Parser = {
  <span class="dt">init</span>: <span class="kw">function</span>(csv) {
    <span class="kw">this</span>.<span class="fu">csv</span> = csv;
    <span class="kw">return</span> <span class="kw">this</span>;
  },
  <span class="dt">parseEmails</span>: <span class="kw">function</span>() {
    ... <span class="co">// not important</span>
    <span class="kw">return</span> emails;
  }
};</code></pre>
<p>Now we have a <code>Parser</code> class that definitely fits the SRP - it knows how to parse data out of a CSV, and that’s the way it should be. We can now go ahead and update our <code>EmailSender</code> object:</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> EmailSender = {
  <span class="dt">init</span>: <span class="kw">function</span>(csv) {
    <span class="kw">this</span>.<span class="fu">csv</span> = csv;
    <span class="kw">return</span> <span class="kw">this</span>;
  },
  <span class="dt">parseEmailsFromCsv</span>: <span class="kw">function</span>() {
    <span class="co">// implementation not important</span>
    <span class="kw">this</span>.<span class="fu">emails</span> = <span class="ot">Parser</span>.<span class="fu">init</span>(<span class="kw">this</span>,csv).<span class="fu">parseEmails</span>()
  },
  <span class="dt">sendEmail</span>: <span class="kw">function</span>() {
    <span class="co">// sends email, implementation not important</span>
    <span class="kw">this</span>.<span class="ot">emails</span>.<span class="fu">forEach</span>(...);
  }
};</code></pre>
<p>Notice how I haven’t changed the methods available on <code>EmailSender</code>, but just the implementation so it uses the new <code>Parser</code> object.</p>
<h2 id="coupling">Coupling</h2>
<p>We are far from done here, but before continuing I want to talk about the concept of <strong>coupling</strong>. In a large system, coupling is the amount two components rely on each other to perform their functions. <a href="http://en.wikipedia.org/wiki/Coupling_(computer_programming)">Wikipedia</a> puts this nicely:</p>
<blockquote>
<p>In software engineering, coupling or dependency is the degree to which each program module relies on each one of the other modules.</p>
</blockquote>
<p>The best way to judge this is to take your two components and ask yourself this question: if one of these components were to change, how much would the other have to change? If the answer is “lots”, those components are tightly coupled. The overall aim is to have most of your components <em>decoupled</em> from each other, so that if one changes, the other doesn’t have to. Have you ever had to make a change to a system, and had to update code in multiple files at the same time? If so, that’s a good indication that all those files and components are perhaps too tightly coupled to each other.</p>
<p>Some coupling is necessary, because without any coupling, no component would ever be able to talk to another, but the less components know about each other, the better.</p>
<p>Looking at our code and where we’re up to, I’d argue that we have some coupling going on that isn’t required.</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> Parser = {
  <span class="dt">init</span>: <span class="kw">function</span>(csv) {
    <span class="kw">this</span>.<span class="fu">csv</span> = csv;
    <span class="kw">return</span> <span class="kw">this</span>;
  },
  <span class="dt">parseEmails</span>: <span class="kw">function</span>() {
    ... <span class="co">// not important</span>
    <span class="kw">return</span> emails;
  }
};

<span class="kw">var</span> EmailSender = {
  <span class="dt">init</span>: <span class="kw">function</span>(csv) {
    <span class="kw">this</span>.<span class="fu">csv</span> = csv;
    <span class="kw">return</span> <span class="kw">this</span>;
  },
  <span class="dt">parseEmailsFromCsv</span>: <span class="kw">function</span>() {
    <span class="co">// implementation not important</span>
    <span class="kw">this</span>.<span class="fu">emails</span> = <span class="ot">Parser</span>.<span class="fu">init</span>(<span class="kw">this</span>,csv).<span class="fu">parseEmails</span>()
  },
  <span class="dt">sendEmail</span>: <span class="kw">function</span>() {
    <span class="co">// sends email, implementation not important</span>
    <span class="kw">this</span>.<span class="ot">emails</span>.<span class="fu">forEach</span>(...);
  }
};</code></pre>
<p>Here, <code>EmailSender</code> knows too much about how it gets emails. It knows that they come from the <code>Parser</code>, which uses a CSV as a data source. Why should the email sender know any of this? All we should give it is a set of emails, and it should do the rest. The next change we make is to decouple the components completely:</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> Parser = {
  <span class="dt">init</span>: <span class="kw">function</span>(csv) {
    <span class="kw">this</span>.<span class="fu">csv</span> = csv;
    <span class="kw">return</span> <span class="kw">this</span>;
  },
  <span class="dt">parseEmails</span>: <span class="kw">function</span>() {
    ... <span class="co">// not important</span>
    <span class="kw">return</span> emails;
  }
};

<span class="kw">var</span> EmailSender = {
  <span class="dt">init</span>: <span class="kw">function</span>(emails) {
    <span class="kw">this</span>.<span class="fu">emails</span> = emails;
    <span class="kw">return</span> <span class="kw">this</span>;
  },
  <span class="dt">sendEmail</span>: <span class="kw">function</span>() {
    <span class="co">// sends email, implementation not important</span>
    <span class="kw">this</span>.<span class="ot">emails</span>.<span class="fu">forEach</span>(...);
  }
};

<span class="kw">var</span> emails = <span class="ot">Parser</span>.<span class="fu">init</span>(csv).<span class="fu">parseEmails</span>();
<span class="ot">EmailSender</span>.<span class="fu">init</span>(emails).<span class="fu">sendEmail</span>();</code></pre>
<p>Notice how now the <code>EmailSender</code> has no knowledge of the <code>Parser</code> even existing. This now means if our data source were to change from being CSV to being from a database for example, we wouldn’t have to change any code. We could introduce a new object responsible for pulling our emails out of the database, and then still use <code>EmailSender</code> just like before.</p>
<h2 id="publish-and-subscribe">Publish and Subscribe</h2>
<p>Moving on to a different example, another method for keeping objects decoupled is the <em>Publish and Subscribe Pattern</em>, or <em>pubsub</em> for short.</p>
<p>In his (freely available online) book, <a href="http://addyosmani.com/resources/essentialjsdesignpatterns/book/">“Learning JavaScript Design Patterns”</a>, Addy Osmani summarises the goal of the pubsub pattern:</p>
<blockquote>
<p>The general idea here is the promotion of loose coupling. Rather than single objects calling on the methods of other objects directly, they instead subscribe to a specific task or activity of another object and are notified when it occurs.</p>
</blockquote>
<p>This approach is particularly suited to browser code, because JavaScript is largely event driven. Let’s look at an example where on the page we have a carousel and some tabs. When the user clicks on a tab to view some content, we want the carousel to stop running, so the user doesn’t miss any of the content on the carousel.</p>
<p>We might do it like so:</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> carousel = {
  <span class="dt">stop</span>: <span class="kw">function</span>() {
    <span class="co">// stop animation</span>
  }
  ...
}

<span class="kw">var</span> tabs = {
   <span class="dt">tabClicked</span>: <span class="kw">function</span>() {
     <span class="ot">carousel</span>.<span class="fu">stop</span>();
   }
   ...
}</code></pre>
<p>This would work fine, but imagine if, along with a carousel, another element is added that needs to stop animating too? You’d have to add it to the <code>tabClicked</code> method:</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> carousel = {
  <span class="dt">stop</span>: <span class="kw">function</span>() {
    <span class="co">// stop animation</span>
  }
  ...
}

<span class="kw">var</span> tabs = {
   <span class="dt">tabClicked</span>: <span class="kw">function</span>() {
     <span class="ot">carousel</span>.<span class="fu">stop</span>();
     <span class="ot">otherThing</span>.<span class="fu">stop</span>();
   }
   ...
}

<span class="kw">var</span> otherThing = {
  <span class="dt">stop</span>: <span class="kw">function</span>() {
    <span class="co">// stop</span>
  }
}</code></pre>
<p>Although this is a slightly contrived example, I hope you can see that over time this is going to lead to some really messy code. It also means that we have to update our <code>tabClicked</code> method every time we add a new item, which is a little odd to me.</p>
<p>We can solve this using pubsub. In pubsub you have an object, typically called <code>events</code> (hold tight, I’ll link to some pubsub libraries you can use shortly). Objects can then use this pubsub object to publish events to, and subscribe to events that other objects publish. Here’s the same code in that previous code block, but using an <code>events</code> object.</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> events = ... <span class="co">//pubsub object</span>

<span class="kw">var</span> carousel = {
  <span class="dt">init</span>: <span class="kw">function</span>() {
    <span class="ot">events</span>.<span class="fu">on</span>(<span class="st">&#39;tabClicked&#39;</span>, <span class="kw">this</span>.<span class="fu">stop</span>);
  },
  <span class="dt">stop</span>: <span class="kw">function</span>() {
    <span class="co">// stop animation</span>
  }
  ...
}

<span class="kw">var</span> tabs = {
   <span class="dt">tabClicked</span>: <span class="kw">function</span>() {
     <span class="ot">events</span>.<span class="fu">publish</span>(<span class="st">&#39;tabClicked&#39;</span>);
   }
   ...
}

<span class="kw">var</span> otherThing = {
  <span class="dt">init</span>: <span class="kw">function</span>() {
    <span class="ot">events</span>.<span class="fu">on</span>(<span class="st">&#39;tabClicked&#39;</span>, <span class="kw">this</span>.<span class="fu">stop</span>);
  },
  <span class="dt">stop</span>: <span class="kw">function</span>() {
    <span class="co">// stop</span>
  }
}</code></pre>
<p>Notice now how the tabs object just published an event, and both the others can just run some code when an event is published. Crucially though, if a new item is added, <strong>the tabs code doesn’t have to change</strong>.</p>
<p>In terms of pubsub implementations, there are a few to choose from:</p>
<ul>
<li><a href="https://github.com/cowboy/jquery-tiny-pubsub">Ben Alman’s tiny-pubsub</a></li>
<li><a href="http://amplifyjs.com/api/pubsub/">AmplifyJS</a></li>
<li><a href="https://github.com/mroderick/PubSubJS">PubSubJS</a></li>
</ul>
<h2 id="conclusion">Conclusion</h2>
<p>In this chapter we discussed the Single Responsibility Principle and the advantages it brings to the table. Getting into the habit of keeping your objects small and concerned with just one thing will make your code and overall applications much more maintainable and easier to work with as your application grows.</p>
<h1 id="tale-5-the-fat-controller">Tale 5: The Fat Controller</h1>
<ul>
<li>controllers should read like a high level story of what they do</li>
<li>internal details should be elsewhere (either in model, or a service)</li>
</ul>
<h1 id="test-driven-development">Test Driven Development</h1>
<p>This chapter is slightly different from the rest. This isn’t a tale of some bad code turned good, but rather how I used test driven development (TTD) to create a function and my thoughts on how this effected the resulting code.</p>
<p>TTD often is thought of as foolish - writing a test that won’t pass because you’ve not written code seems unintuitive. The key thing that it does allow you to do is interact with the new code you’re about to write, and get a feel for what the API should look like. That’s a great benefit, and often I’ve rewritten tests many times as I figure out what the public API of the new object I’m building should look like. Another benefit though, is it lets you take small steps to successfully implementing a function. You can write your tests one at a time, and get them green one by one. Write one, make it green, and then write the next. At any point if you break a previous test, you’ll know right away. It’s that confidence that you’ve not inadvertently broken something that I enjoy most about a good test suite.</p>
<h2 id="the-service">The Service</h2>
<p>I’m working on an application where users have these objects, called “clusters”, that are groups of posts from another site. They can share these clusters with other users, who can subscribe to them. However, users can choose to keep their clusters private, and so only they can see them. I needed to build some logic for deciding if a user is allowed to subscribe to a cluster. There are various rules that govern this:</p>
<ul>
<li>If a user is the owner of the cluster, they cannot subscribe, because they are implictly subscribed to it by owning it.</li>
<li>If the user is an admin of the cluster, they cannot subscribe, for the same reason as above.</li>
<li>If the cluster is private, no user can subscribe to it.</li>
<li>If a user is already subscribed to the cluster, they cannot subscribe to it again.</li>
</ul>
<p>Else, if none of the four above conditions match, the user is allowed to subscribe.</p>
<h2 id="test-driven">Test Driven</h2>
<p>This is the perfect example of a function that is very easy to test. Given specific input, it will either return <code>true</code> (the user can subscribe), or <code>false</code> (the user cannot subscribe). There are a few conditions we need to make sure we adhere to, so a set of unit tests is the perfect way to do this.</p>
<p>Let’s write the first test. Here I’m using the <a href="http://jasmine.github.io/2.0/introduction.html">Jasmine testing library</a>, but if you prefer another, feel free to use it instead. Jasmine is just my framework of choice for testing JS on the client. The actual implementation of this code was done within Angular, so in the tests there’s a fair amount of setup for that, which I’m ignoring here. The best way to test drive this is to write one spec, make it pass <em>in the easiest way possible</em>, and then write the next one.</p>
<p>Here’s my first test:</p>
<pre class="js"><code>it(&#39;returns true if the user is not admin or owner and the cluster is public&#39;, function() {
  var res = UserCanSubscribeService.canSubscribe({
    id: &#39;abcd&#39;
  }, {
    public: true,
    admins: [],
    subscribers: [],
    owner: &#39;cdef&#39;
  });
  expect(res).toEqual(true);
});</code></pre>
<p>Here I’m stating that the <code>canSubscribe</code> method takes two arguments: the first is the user object, which for testing purposes can just contain an ID. The second object is then the cluster that they may or may not be allowed to subscribe to. In this instance, the user is not the cluster owner, is not an admin, has not subscribed already and the cluster is public, so they are able to subscribe.</p>
<p>The simplest implementation to make this work?</p>
<pre class="js"><code>UserCanSubscribeService = {};
UserCanSubscribeService.canSubscribe = function() {
  return true;
}</code></pre>
<p>The test passes, but obviously that implementation needs a bit more work doing. However the point here, even if this might seem a little pointless, is to go one test at a time and make small steps. What this does is stops you over complicating your initial approach and potentially abstracting in the wrong place. A bad abstraction is worse than no abstraction, and by waiting until you have more code and context, you are more likely to pick the right abstraction.</p>
<h2 id="conclusion-1">Conclusion</h2>
<p>The above code has been altered slightly for easier reading, but I did actually write this service in a real application. If you’re interested, you can <a href="https://github.com/clusterapp/client/tree/master/app/shared/user-can-subscribe-service">find it on GitHub</a>.</p>
</body>
</html>
